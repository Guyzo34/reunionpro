{"version":3,"file":"daily-react.cjs.production.min.js","sources":["../src/DailyContext.tsx","../src/hooks/useDaily.ts","../src/DailyEventContext.tsx","../src/hooks/useDailyEvent.ts","../src/hooks/useParticipantProperty.ts","../src/hooks/useThrottledDailyEvent.ts","../src/lib/customDeepEqual.ts","../src/lib/recoil-custom.ts","../src/utils/getParticipantPaths.ts","../src/utils/resolveParticipantPaths.ts","../src/DailyParticipants.tsx","../src/hooks/useLocalSessionId.ts","../src/hooks/useActiveSpeakerId.ts","../src/utils/isTrackOff.ts","../src/hooks/useParticipantIds.ts","../src/hooks/useScreenShare.ts","../src/hooks/useMediaTrack.ts","../src/hooks/useMergedRef.ts","../src/components/DailyAudioTrack.tsx","../src/components/DailyAudio.tsx","../src/components/DailyVideo.tsx","../src/DailyDevicesContext.tsx","../src/DailyDevices.tsx","../src/DailyLiveStreaming.tsx","../src/DailyMeeting.tsx","../src/DailyNetwork.tsx","../src/DailyRecordings.tsx","../src/hooks/useMeetingState.ts","../src/DailyRoom.tsx","../src/DailyTranscriptions.tsx","../src/hooks/useCallInstance.ts","../src/hooks/useCallObject.ts","../src/hooks/useParticipant.ts","../src/lib/inlineAudioWorklet.ts","../src/hooks/useCPULoad.ts","../src/hooks/useDailyError.ts","../src/hooks/useInputSettings.ts","../src/hooks/useParticipantCounts.ts","../src/hooks/useReceiveSettings.ts","../src/hooks/useRoom.ts","../src/hooks/useSendSettings.ts","../src/DailyProvider.tsx","../src/hooks/useActiveParticipant.ts","../src/hooks/useAppMessage.ts","../src/hooks/useAudioLevel.ts","../src/hooks/useAudioTrack.ts","../src/hooks/useCallFrame.ts","../src/hooks/useDevices.ts","../src/hooks/useLiveStreaming.ts","../src/hooks/useLocalParticipant.ts","../src/hooks/useMeetingSessionState.ts","../src/hooks/useNetwork.ts","../src/hooks/usePermissions.ts","../src/hooks/useRecording.ts","../src/hooks/useRoomExp.ts","../src/hooks/useScreenAudioTrack.ts","../src/hooks/useScreenVideoTrack.ts","../src/hooks/useTranscription.ts","../src/hooks/useVideoTrack.ts","../src/hooks/useWaitingParticipants.ts"],"sourcesContent":["import { DailyCall } from '@daily-co/daily-js';\nimport { createContext } from 'react';\n\nexport const DailyContext = createContext<DailyCall | null>(null);\n","import { useContext, useDebugValue } from 'react';\n\nimport { DailyContext } from '../DailyContext';\n\n/**\n * Returns callObject instance passed to or created by closest <DailyProvider>.\n */\nexport const useDaily = () => {\n  const daily = useContext(DailyContext);\n  useDebugValue(daily);\n  return daily;\n};\n","import { DailyEvent } from '@daily-co/daily-js';\nimport { createContext } from 'react';\n\ninterface EventContextValue {\n  on(ev: DailyEvent, callback: Function, key: number): void;\n  off(ev: DailyEvent, key: number): void;\n}\n\nexport const DailyEventContext = createContext<EventContextValue>({\n  on: () => {},\n  off: () => {},\n});\n","import { DailyEvent, DailyEventObject } from '@daily-co/daily-js';\nimport {\n  useContext,\n  useDebugValue,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\n\nimport { DailyEventContext } from '../DailyEventContext';\n\ntype EventCallback<T extends DailyEvent> = (event: DailyEventObject<T>) => void;\n\nlet uniqueCounter = 0;\nexport const getUnique = () => uniqueCounter++;\n\n/**\n * Sets up a daily event listener using [on](https://docs.daily.co/reference/daily-js/instance-methods/on) method.\n * When this hook is unmounted the event listener is unregistered using [off](https://docs.daily.co/reference/daily-js/instance-methods/off).\n *\n * Warning: callback has to be a memoized reference (e.g. via [useCallback](https://reactjs.org/docs/hooks-reference.html#usecallback)).\n * Otherwise a console error might be thrown indicating a re-render loop issue.\n *\n * @param ev The DailyEvent to register.\n * @param callback A memoized callback reference to run when the event is emitted.\n */\nexport const useDailyEvent = <T extends DailyEvent>(\n  ev: T,\n  callback: EventCallback<T>\n) => {\n  const { off, on } = useContext(DailyEventContext);\n  const [isBlocked, setIsBlocked] = useState(false);\n  const reassignCount = useRef<number>(0);\n\n  const eventId = useMemo(() => getUnique(), []);\n\n  useEffect(() => {\n    if (!ev || isBlocked) return;\n    /**\n     * Check if callback has been reassigned often enough without hitting the 50ms timeout.\n     */\n    if (reassignCount.current > 100000) {\n      console.error(\n        `useDailyEvent called with potentially non-memoized event callback or due to too many re-renders.\n        Memoize using useCallback to avoid re-render loop or reduce the amount of state transitions the callback depends on.\n        Passed callback for '${ev}' event is NOT registered.`,\n        callback\n      );\n      setIsBlocked(true);\n      return;\n    }\n    reassignCount.current++;\n    const timeout = setTimeout(() => {\n      reassignCount.current = 0;\n    }, 50);\n    on(ev, callback, eventId);\n    return () => {\n      clearTimeout(timeout);\n      off(ev, eventId);\n    };\n  }, [callback, ev, eventId, isBlocked, off, on]);\n\n  useDebugValue({\n    event: ev,\n    eventId,\n    isBlocked,\n    callback,\n  });\n};\n","import { useDebugValue } from 'react';\nimport { atomFamily, selectorFamily, useRecoilValue } from 'recoil';\n\nimport { ExtendedDailyParticipant } from '../DailyParticipants';\nimport { RECOIL_PREFIX } from '../lib/constants';\nimport type { NumericKeys } from '../types/NumericKeys';\nimport type { Paths } from '../types/paths';\nimport type { PathValue } from '../types/pathValue';\n\ntype PropertyType = {\n  id: string;\n  property: Paths<ExtendedDailyParticipant>;\n};\n\ntype PropertiesType = {\n  id: string;\n  properties: Paths<ExtendedDailyParticipant>[];\n};\n\n/**\n * Stores all property paths for a given participant.\n */\nexport const participantPropertyPathsState = atomFamily<\n  Paths<ExtendedDailyParticipant>[],\n  string\n>({\n  key: RECOIL_PREFIX + 'participant-property-paths',\n  default: [],\n});\n\n/**\n * Stores resolved values for each participant and property path.\n */\nexport const participantPropertyState = atomFamily<any, PropertyType>({\n  key: RECOIL_PREFIX + 'participant-property',\n  default: null,\n  dangerouslyAllowMutability: true, // daily-js mutates track props (_managedByDaily, etc)\n});\n\n/**\n * Stores resolved values for each participant and property path.\n */\nexport const participantPropertiesState = selectorFamily<any, PropertiesType>({\n  key: RECOIL_PREFIX + 'participant-properties',\n  get:\n    ({ id, properties }) =>\n    ({ get }) => {\n      return properties.map((path) =>\n        get(participantPropertyState({ id, property: path }))\n      );\n    },\n  dangerouslyAllowMutability: true, // daily-js mutates track props (_managedByDaily, etc)\n});\n\ntype UseParticipantPropertyReturnType<\n  T extends ExtendedDailyParticipant,\n  P extends Paths<T> | Paths<T>[]\n> = P extends Paths<T>[]\n  ? { [K in keyof P]: K extends NumericKeys ? PathValue<T, P[K]> : unknown }\n  : P extends Paths<T>\n  ? PathValue<T, P>\n  : never;\n\n/**\n * Returns a participant's property that you subscribe to.\n * @param participantId The participant's session_id.\n * @param propertyPaths the array of participant property that you want to subscribe to.\n */\nexport const useParticipantProperty = <\n  T extends ExtendedDailyParticipant = ExtendedDailyParticipant,\n  P extends Paths<T> | [Paths<T>, ...Paths<T>[]] =\n    | Paths<T>\n    | [Paths<T>, ...Paths<T>[]]\n>(\n  participantId: string,\n  propertyPaths: P\n): UseParticipantPropertyReturnType<T, P> => {\n  const properties = useRecoilValue(\n    Array.isArray(propertyPaths)\n      ? participantPropertiesState({\n          id: participantId,\n          properties: propertyPaths as Paths<ExtendedDailyParticipant>[],\n        })\n      : participantPropertyState({\n          id: participantId,\n          property: propertyPaths as Paths<ExtendedDailyParticipant>,\n        })\n  );\n\n  useDebugValue(\n    Array.isArray(propertyPaths)\n      ? propertyPaths.reduce(\n          (o: Record<any, any>, path: Paths<T>, i: number) => {\n            o[path] = properties[i];\n            return o;\n          },\n          {}\n        )\n      : {\n          [propertyPaths as any]: properties,\n        }\n  );\n\n  return properties;\n};\n","import { DailyEvent, DailyEventObject } from '@daily-co/daily-js';\nimport throttle from 'lodash.throttle';\nimport {\n  useCallback,\n  useContext,\n  useDebugValue,\n  useEffect,\n  useMemo,\n  useRef,\n} from 'react';\n\nimport { DailyEventContext } from '../DailyEventContext';\nimport { getUnique, useDailyEvent } from './useDailyEvent';\n\ntype EnsureArray<T> = T extends DailyEvent ? [T] : T;\n\ntype EventObjectsFor<T> = EnsureArray<T> extends (infer U)[]\n  ? U extends DailyEvent\n    ? DailyEventObject<U>\n    : never\n  : never;\n\ntype EventCallback<T extends DailyEvent | DailyEvent[]> = (\n  events: EventObjectsFor<T>[]\n) => void;\n\n/**\n * Sets up a throttled daily event listener using [on](https://docs.daily.co/reference/daily-js/instance-methods/on) method.\n * When this hook is unmounted the event listener is unregistered using [off](https://docs.daily.co/reference/daily-js/instance-methods/off).\n *\n * In comparison to useDailyEvent the callback passed here will be called with an array of event objects.\n *\n * You can pass an array of DailyEvents to register multiple daily events with a single callback handler.\n * The events returned in the callback parameter are guaranteed to be in the same order as they were emitted.\n *\n * @param ev The DailyEvent to register or an array of DailyEvent to register.\n * @param callback A memoized callback reference to run when throttled events are emitted.\n * @param throttleTimeout The minimum waiting time until the callback is called again. Default: 100\n */\nexport const useThrottledDailyEvent = <T extends DailyEvent>(\n  ev: T | T[],\n  callback: EventCallback<EnsureArray<T>>,\n  throttleTimeout = 500\n) => {\n  const { off, on } = useContext(DailyEventContext);\n  const eventId = useMemo(() => {\n    if (Array.isArray(ev))\n      return ev.reduce<Record<string, number>>((r, e) => {\n        r[e] = getUnique();\n        return r;\n      }, {});\n    return { [ev]: getUnique() };\n  }, [ev]);\n\n  const throttledEvents = useRef<EventObjectsFor<T>[]>([]);\n\n  useDailyEvent(\n    'call-instance-destroyed',\n    useCallback(() => {\n      throttledEvents.current.length = 0;\n    }, [])\n  );\n\n  const emitEvents = useMemo(\n    () =>\n      throttle(\n        () => {\n          if (throttledEvents.current.length === 0) return;\n          callback(throttledEvents.current);\n          throttledEvents.current.length = 0;\n        },\n        throttleTimeout,\n        {\n          trailing: true,\n        }\n      ),\n    [callback, throttleTimeout]\n  );\n\n  useEffect(() => {\n    if (!ev) return;\n    const addEvent = (ev: DailyEventObject) => {\n      throttledEvents.current.push(ev);\n      emitEvents();\n    };\n    if (Array.isArray(ev)) {\n      ev.forEach((e) => on(e, addEvent, eventId[e]));\n    } else {\n      on(ev, addEvent, eventId[ev]);\n    }\n    return () => {\n      if (Array.isArray(ev)) {\n        ev.forEach((e) => off(e, eventId[e]));\n      } else {\n        off(ev, eventId[ev]);\n      }\n    };\n  }, [emitEvents, ev, eventId, off, on]);\n\n  useDebugValue({\n    event: ev,\n    eventId,\n  });\n};\n","/**\n * Compares two variables for deep equality.\n * Gracefully handles equality checks on MediaStreamTracks by comparing their ids.\n */\nexport function customDeepEqual(a: any, b: any): boolean {\n  if (a === b) return true;\n\n  // Handle special case for MediaStream\n  if (a instanceof MediaStream && b instanceof MediaStream) {\n    return (\n      a.id === b.id &&\n      a.active === b.active &&\n      a.getTracks().length === b.getTracks().length &&\n      a\n        .getTracks()\n        .every((track, idx) => customDeepEqual(track, b.getTracks()[idx]))\n    );\n  }\n\n  // Handle special case for MediaStreamTrack\n  if (a instanceof MediaStreamTrack && b instanceof MediaStreamTrack) {\n    return a.id === b.id && a.kind === b.kind && a.readyState === b.readyState;\n  }\n\n  // Handle special case for Date\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  }\n\n  // Handle special case for RegExp\n  if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source === b.source && a.flags === b.flags;\n  }\n\n  // Handle special case for Set\n  if (a instanceof Set && b instanceof Set) {\n    if (a.size !== b.size) {\n      return false;\n    }\n\n    for (const value of a.values()) {\n      if (!b.has(value)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // Handle special case for Map\n  if (a instanceof Map && b instanceof Map) {\n    if (a.size !== b.size) {\n      return false;\n    }\n    for (const [key, value] of a.entries()) {\n      if (!b.has(key)) {\n        return false;\n      }\n      if (!customDeepEqual(value, b.get(key))) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // If a or b are not objects or null, they can't be deeply equal\n  if (\n    typeof a !== 'object' ||\n    a === null ||\n    typeof b !== 'object' ||\n    b === null\n  ) {\n    return false;\n  }\n\n  // Get the keys of a and b. This handles both arrays and objects, since arrays are technically objects.\n  let keysA = Object.keys(a);\n  let keysB = Object.keys(b);\n\n  // If the number of keys are different, the objects are not equal\n  if (keysA.length !== keysB.length) return false;\n\n  for (let key of keysA) {\n    if (\n      // If key exists in a, but not in b -> not equal\n      !(key in b) ||\n      // Both keys exist in both object -> run nested equality check\n      !customDeepEqual(a[key], b[key])\n    )\n      return false;\n  }\n\n  // All keys and values match -> the objects are deeply equal\n  return true;\n}\n","import {\n  ReadOnlySelectorFamilyOptions,\n  ReadOnlySelectorOptions,\n  RecoilValueReadOnly,\n  selector,\n  selectorFamily,\n  SerializableParam,\n} from 'recoil';\n\ninterface EqualSelectorOptions<T>\n  extends Pick<ReadOnlySelectorOptions<T>, 'key' | 'get'> {\n  equals: (a: T, b: T) => boolean;\n}\n\n/**\n * Same API as [selector](https://recoiljs.org/docs/api-reference/core/selector), but with an additional `equals` key.\n * Allows to run custom equality checks before returning a new calculated value.\n * Use this, when returning non-primitive types from state.\n * Resource: https://github.com/facebookexperimental/Recoil/issues/1416#issuecomment-1044953271\n */\nexport function equalSelector<T>(\n  options: EqualSelectorOptions<T>\n): RecoilValueReadOnly<T> {\n  const inner = selector({\n    key: `${options.key}_inner`,\n    get: options.get,\n  });\n\n  let prior: T | undefined;\n\n  return selector({\n    key: options.key,\n    get: ({ get }) => {\n      const latest = get(inner);\n      if (prior != null && options.equals(latest, prior)) {\n        return prior;\n      }\n      prior = latest;\n      return latest as T;\n    },\n  });\n}\n\ninterface EqualSelectorFamilyOptions<T, P extends SerializableParam>\n  extends Pick<ReadOnlySelectorFamilyOptions<T, P>, 'key' | 'get'> {\n  equals: (a: T, b: T) => boolean;\n}\n\n/**\n * Same API as [selectorFamily](https://recoiljs.org/docs/api-reference/utils/selectorFamily/), but with an additional `equals` key.\n * Allows to run custom equality checks before returning a new calculated value.\n * Use this, when returning non-primitive types from state.\n * Resource: https://github.com/facebookexperimental/Recoil/issues/1416#issuecomment-1168603409\n */\nexport function equalSelectorFamily<T, P extends SerializableParam>(\n  options: EqualSelectorFamilyOptions<T, P>\n) {\n  const inner = selectorFamily<T, P>({\n    key: `${options.key}_inner`,\n    get: options.get,\n  });\n\n  const priorValues: Map<P, T | undefined> = new Map();\n\n  return selectorFamily<T, P>({\n    ...options,\n    key: options.key,\n    get:\n      (param: P) =>\n      ({ get }) => {\n        const latest = get(inner(param));\n        const prior = priorValues.get(param);\n        if (prior != null && options.equals(latest, prior)) {\n          return prior;\n        }\n        priorValues.set(param, latest);\n        return latest;\n      },\n  });\n}\n","import { ExtendedDailyParticipant } from '../DailyParticipants';\nimport { Paths } from '../types/paths';\n\n/**\n * Returns all property paths for an object.\n */\nconst getPaths = (o: Record<any, any>, currentPath = ''): string[] => {\n  if (typeof o !== 'object' || o === null) {\n    return [currentPath];\n  }\n\n  const paths = [];\n  for (const key in o) {\n    if (Object.prototype.hasOwnProperty.call(o, key)) {\n      const newPath = currentPath ? `${currentPath}.${key}` : key;\n      paths.push(newPath, ...getPaths(o[key], newPath));\n    }\n  }\n\n  return paths;\n};\n\n/**\n * Returns all property paths for a given participant object.\n */\nexport const getParticipantPaths = (p: ExtendedDailyParticipant) => {\n  return getPaths(p) as Paths<ExtendedDailyParticipant>[];\n};\n","import { ExtendedDailyParticipant } from '../DailyParticipants';\nimport type { NumericKeys } from '../types/NumericKeys';\nimport type { Paths } from '../types/paths';\nimport type { PathValue } from '../types/pathValue';\n\nconst resolvePath = <T extends ExtendedDailyParticipant, P extends Paths<T>>(\n  participant: T | null,\n  path: P\n): PathValue<T, P> => {\n  return String(path)\n    .split('.')\n    .filter((key) => key.length)\n    .reduce((p: any, key) => p && p[key], participant);\n};\n\ntype ResolveParticipantPathsReturnType<\n  T extends ExtendedDailyParticipant,\n  P extends Paths<T>[]\n> = { [K in keyof P]: K extends NumericKeys ? PathValue<T, P[K]> : never };\n\nexport const resolveParticipantPaths = <\n  T extends ExtendedDailyParticipant,\n  P extends Paths<T>[]\n>(\n  participant: T | null,\n  paths: P\n): ResolveParticipantPathsReturnType<T, P> => {\n  return paths.map((path) =>\n    resolvePath(participant, path)\n  ) as ResolveParticipantPathsReturnType<T, P>;\n};\n","import {\n  DailyParticipant,\n  DailyParticipantsObject,\n  DailyParticipantTracks,\n  DailyWaitingParticipant,\n} from '@daily-co/daily-js';\nimport React, { useCallback, useEffect, useState } from 'react';\nimport { atom, atomFamily, selector, useRecoilCallback } from 'recoil';\n\nimport { useDaily } from './hooks/useDaily';\nimport { useDailyEvent } from './hooks/useDailyEvent';\nimport {\n  participantPropertyPathsState,\n  participantPropertyState,\n} from './hooks/useParticipantProperty';\nimport { useThrottledDailyEvent } from './hooks/useThrottledDailyEvent';\nimport { RECOIL_PREFIX } from './lib/constants';\nimport { customDeepEqual } from './lib/customDeepEqual';\nimport { equalSelector } from './lib/recoil-custom';\nimport { getParticipantPaths } from './utils/getParticipantPaths';\nimport { resolveParticipantPaths } from './utils/resolveParticipantPaths';\n\n/**\n * Extends DailyParticipant with convenient additional properties.\n * The `tracks` object needs to omit custom track keys, otherwise\n * autocomplete for `tracks` in useParticipantProperty doesn't work.\n */\nexport interface ExtendedDailyParticipant\n  extends Omit<DailyParticipant, 'tracks'> {\n  last_active?: Date;\n  tracks: DailyParticipantTracks;\n}\n\n/**\n * Stores the most recent peerId as reported from [active-speaker-change](https://docs.daily.co/reference/daily-js/events/meeting-events#active-speaker-change) event.\n */\nexport const activeIdState = atom<string | null>({\n  key: RECOIL_PREFIX + 'active-id',\n  default: null,\n});\n\nexport const localIdState = atom<string>({\n  key: RECOIL_PREFIX + 'local-id',\n  default: '',\n});\n\nexport const localJoinDateState = atom<Date | null>({\n  key: RECOIL_PREFIX + 'local-joined-date',\n  default: null,\n});\n\nexport const participantIdsState = atom<string[]>({\n  key: RECOIL_PREFIX + 'participant-ids',\n  default: [],\n});\n\nexport const participantState = atomFamily<\n  ExtendedDailyParticipant | null,\n  string\n>({\n  key: RECOIL_PREFIX + 'participant-state',\n  default: null,\n  dangerouslyAllowMutability: true, // daily-js mutates track props (_managedByDaily, etc)\n});\n\nexport const participantsState = selector<ExtendedDailyParticipant[]>({\n  key: RECOIL_PREFIX + 'participants',\n  get: ({ get }) => {\n    const ids = get(participantIdsState);\n    const participants = ids\n      .map((id) => get(participantState(id)))\n      .filter(Boolean) as ExtendedDailyParticipant[];\n    return participants;\n  },\n  dangerouslyAllowMutability: true, // daily-js mutates track props (_managedByDaily, etc)\n});\n\n/**\n * Holds all participants in the waiting room.\n */\nexport const waitingParticipantsState = atom<string[]>({\n  key: RECOIL_PREFIX + 'waiting-participants',\n  default: [],\n});\n\n/**\n * Holds each invidiual waiting participant's information.\n */\nexport const waitingParticipantState = atomFamily<\n  DailyWaitingParticipant,\n  string\n>({\n  key: RECOIL_PREFIX + 'waiting-participant',\n  default: {\n    awaitingAccess: {\n      level: 'full',\n    },\n    id: '',\n    name: '',\n  },\n});\n\n/**\n * Returns all waiting participant objects in an array.\n */\nexport const allWaitingParticipantsSelector = equalSelector({\n  key: RECOIL_PREFIX + 'waitingParticipantsSelector',\n  equals: customDeepEqual,\n  get: ({ get }) => {\n    const ids = get(waitingParticipantsState);\n    return ids.map((id) => get(waitingParticipantState(id)));\n  },\n});\n\nexport const DailyParticipants: React.FC<React.PropsWithChildren<{}>> = ({\n  children,\n}) => {\n  const daily = useDaily();\n  const [initialized, setInitialized] = useState(false);\n\n  const initParticipants = useRecoilCallback(\n    ({ transact_UNSTABLE }) =>\n      (participants: DailyParticipantsObject) => {\n        transact_UNSTABLE(({ set }) => {\n          set(localIdState, participants.local.session_id);\n          const participantsArray = Object.values(participants);\n          const ids = participantsArray.map((p) => p.session_id);\n          set(participantIdsState, ids);\n          participantsArray.forEach((p) => {\n            set(participantState(p.session_id), p);\n            const paths = getParticipantPaths(p);\n            // Set list of property paths\n            set(participantPropertyPathsState(p.session_id), paths);\n            // Set all property path values\n            paths.forEach((property) => {\n              const [value] = resolveParticipantPaths(\n                p as ExtendedDailyParticipant,\n                [property]\n              );\n              set(\n                participantPropertyState({\n                  id: p.session_id,\n                  property,\n                }),\n                value\n              );\n            });\n          });\n          setInitialized(true);\n        });\n      },\n    []\n  );\n  /**\n   * Initialize participants state based on daily.participants().\n   * Retries every 100ms to initialize the state, until daily is ready.\n   */\n  useEffect(() => {\n    if (!daily || initialized) return;\n    const interval = setInterval(() => {\n      const participants = daily.participants();\n      if (!('local' in participants)) return;\n      initParticipants(participants);\n      clearInterval(interval);\n    }, 100);\n    return () => {\n      clearInterval(interval);\n    };\n  }, [daily, initialized, initParticipants]);\n  const handleInitEvent = useCallback(() => {\n    if (!daily) return;\n    const participants = daily?.participants();\n    if (!participants.local) return;\n    initParticipants(participants);\n  }, [daily, initParticipants]);\n  useDailyEvent('started-camera', handleInitEvent);\n  useDailyEvent('access-state-updated', handleInitEvent);\n  useDailyEvent(\n    'joining-meeting',\n    useRecoilCallback(\n      ({ set }) =>\n        () => {\n          set(localJoinDateState, new Date());\n          handleInitEvent();\n        },\n      [handleInitEvent]\n    )\n  );\n  useDailyEvent(\n    'joined-meeting',\n    useCallback(\n      (ev) => {\n        initParticipants(ev.participants);\n      },\n      [initParticipants]\n    )\n  );\n\n  useThrottledDailyEvent(\n    [\n      'active-speaker-change',\n      'call-instance-destroyed',\n      'left-meeting',\n      'participant-joined',\n      'participant-updated',\n      'participant-left',\n    ],\n    useRecoilCallback(\n      ({ transact_UNSTABLE }) =>\n        (evts) => {\n          transact_UNSTABLE(({ get, reset, set }) => {\n            evts.forEach((ev) => {\n              switch (ev.action) {\n                case 'active-speaker-change': {\n                  set(activeIdState, ev.activeSpeaker.peerId);\n                  set(participantState(ev.activeSpeaker.peerId), (prev) => {\n                    if (!prev) return null;\n                    return {\n                      ...prev,\n                      last_active: new Date(),\n                    };\n                  });\n                  break;\n                }\n                case 'participant-joined': {\n                  // Update list of ids\n                  set(participantIdsState, (prevIds) =>\n                    prevIds.includes(ev.participant.session_id)\n                      ? prevIds\n                      : [...prevIds, ev.participant.session_id]\n                  );\n                  // Store entire object\n                  set(\n                    participantState(ev.participant.session_id),\n                    ev.participant\n                  );\n\n                  const paths = getParticipantPaths(ev.participant);\n                  // Set list of property paths\n                  set(\n                    participantPropertyPathsState(ev.participant.session_id),\n                    paths\n                  );\n                  // Set all property path values\n                  paths.forEach((property) => {\n                    const [value] = resolveParticipantPaths(\n                      ev.participant as ExtendedDailyParticipant,\n                      [property]\n                    );\n                    set(\n                      participantPropertyState({\n                        id: ev.participant.session_id,\n                        property,\n                      }),\n                      value\n                    );\n                  });\n                  break;\n                }\n                case 'participant-updated': {\n                  // Update entire object\n                  set(participantState(ev.participant.session_id), (prev) => ({\n                    ...prev,\n                    ...ev.participant,\n                  }));\n                  // Update local session_id\n                  if (ev.participant.local) {\n                    set(localIdState, (prevId) =>\n                      prevId !== ev.participant.session_id\n                        ? ev.participant.session_id\n                        : prevId\n                    );\n                  }\n\n                  const paths = getParticipantPaths(ev.participant);\n                  const oldPaths = get(\n                    participantPropertyPathsState(ev.participant.session_id)\n                  );\n                  // Set list of property paths\n                  set(\n                    participantPropertyPathsState(ev.participant.session_id),\n                    (prev) => (customDeepEqual(prev, paths) ? prev : paths)\n                  );\n                  // Reset old path values\n                  oldPaths\n                    .filter((p) => !paths.includes(p))\n                    .forEach((property) => {\n                      reset(\n                        participantPropertyState({\n                          id: ev.participant.session_id,\n                          property,\n                        })\n                      );\n                    });\n                  // Set all property path values\n                  paths.forEach((property) => {\n                    const [value] = resolveParticipantPaths(\n                      ev.participant as ExtendedDailyParticipant,\n                      [property]\n                    );\n                    set(\n                      participantPropertyState({\n                        id: ev.participant.session_id,\n                        property,\n                      }),\n                      (prev) => (customDeepEqual(prev, value) ? prev : value)\n                    );\n                  });\n                  break;\n                }\n                case 'participant-left': {\n                  // Remove from list of ids\n                  set(participantIdsState, (prevIds) =>\n                    prevIds.includes(ev.participant.session_id)\n                      ? [\n                          ...prevIds.filter(\n                            (id) => id !== ev.participant.session_id\n                          ),\n                        ]\n                      : prevIds\n                  );\n                  // Remove entire object\n                  reset(participantState(ev.participant.session_id));\n\n                  const oldPaths = get(\n                    participantPropertyPathsState(ev.participant.session_id)\n                  );\n                  // Remove property path values\n                  oldPaths.forEach((property) => {\n                    reset(\n                      participantPropertyState({\n                        id: ev.participant.session_id,\n                        property,\n                      })\n                    );\n                  });\n                  // Remove all property paths\n                  reset(\n                    participantPropertyPathsState(ev.participant.session_id)\n                  );\n                  break;\n                }\n                /**\n                 * Reset stored participants, when meeting has ended.\n                 */\n                case 'call-instance-destroyed':\n                case 'left-meeting': {\n                  reset(localIdState);\n                  const ids = get(participantIdsState);\n                  if (Array.isArray(ids))\n                    ids.forEach((id) => reset(participantState(id)));\n                  reset(participantIdsState);\n                  break;\n                }\n              }\n            });\n          });\n        },\n      []\n    )\n  );\n\n  useThrottledDailyEvent(\n    [\n      'waiting-participant-added',\n      'waiting-participant-updated',\n      'waiting-participant-removed',\n    ],\n    useRecoilCallback(\n      ({ transact_UNSTABLE }) =>\n        (evts) => {\n          transact_UNSTABLE(({ reset, set }) => {\n            evts.forEach((ev) => {\n              switch (ev.action) {\n                case 'waiting-participant-added':\n                  set(waitingParticipantsState, (wps) => {\n                    if (!wps.includes(ev.participant.id)) {\n                      return [...wps, ev.participant.id];\n                    }\n                    return wps;\n                  });\n                  set(\n                    waitingParticipantState(ev.participant.id),\n                    ev.participant\n                  );\n                  break;\n                case 'waiting-participant-updated':\n                  set(\n                    waitingParticipantState(ev.participant.id),\n                    ev.participant\n                  );\n                  break;\n                case 'waiting-participant-removed':\n                  set(waitingParticipantsState, (wps) =>\n                    wps.filter((wp) => wp !== ev.participant.id)\n                  );\n                  reset(waitingParticipantState(ev.participant.id));\n                  break;\n              }\n            });\n          });\n        },\n      []\n    )\n  );\n\n  return <>{children}</>;\n};\n","import { useDebugValue } from 'react';\nimport { useRecoilValue } from 'recoil';\n\nimport { localIdState } from '../DailyParticipants';\n\n/**\n * Returns the local participant's session_id or empty string '',\n * if the local participant doesn't exist.\n */\nexport const useLocalSessionId = () => {\n  const localId = useRecoilValue(localIdState);\n  useDebugValue(localId);\n  return localId;\n};\n","import { useDebugValue, useEffect, useState } from 'react';\nimport { useRecoilValue } from 'recoil';\n\nimport { activeIdState } from '../DailyParticipants';\nimport { useLocalSessionId } from './useLocalSessionId';\n\ninterface UseActiveSpeakerIdArgs {\n  /**\n   * Anytime the active-speaker-change event emits a new id, this callback can be used\n   * to determine if the new speaker id should be ignored or not.\n   * Return false from the callback to ignore the new speaker id in this hook's instance.\n   */\n  filter?(id: string | null): boolean;\n  /**\n   * If set to true, useActiveParticipant will never return the local participant.\n   */\n  ignoreLocal?: boolean;\n}\n\nconst noopFilter = () => true;\n\n/**\n * Returns the most recent speaker id mentioned in an [active-speaker-change](https://docs.daily.co/reference/daily-js/events/meeting-events#active-speaker-change) event.\n */\nexport const useActiveSpeakerId = ({\n  filter = noopFilter,\n  ignoreLocal = false,\n}: UseActiveSpeakerIdArgs = {}) => {\n  const localSessionId = useLocalSessionId();\n  const recentActiveId = useRecoilValue(activeIdState);\n  const isIgnoredLocalId = ignoreLocal && recentActiveId === localSessionId;\n  const isFilteredOut = !filter?.(recentActiveId);\n  const isRecentIdRelevant = !isIgnoredLocalId && !isFilteredOut;\n  const [activeId, setActiveId] = useState<string | null>(\n    isRecentIdRelevant ? recentActiveId : null\n  );\n\n  useEffect(() => {\n    if (isIgnoredLocalId || isFilteredOut) return;\n    setActiveId(recentActiveId);\n  }, [isFilteredOut, isIgnoredLocalId, recentActiveId]);\n\n  useDebugValue(activeId);\n\n  return activeId;\n};\n","import { DailyTrackState } from '@daily-co/daily-js';\n\nexport const isTrackOff = (trackState: DailyTrackState['state']) =>\n  ['blocked', 'off'].includes(trackState);\n","import { DailyEventObject } from '@daily-co/daily-js';\nimport { useCallback, useDebugValue, useEffect, useState } from 'react';\nimport { useRecoilCallback, useRecoilValue } from 'recoil';\n\nimport {\n  ExtendedDailyParticipant,\n  participantIdsState,\n  participantState,\n} from '../DailyParticipants';\nimport { RECOIL_PREFIX } from '../lib/constants';\nimport { customDeepEqual } from '../lib/customDeepEqual';\nimport { equalSelectorFamily } from '../lib/recoil-custom';\nimport { isTrackOff } from '../utils/isTrackOff';\nimport {\n  participantPropertiesState,\n  participantPropertyState,\n} from './useParticipantProperty';\nimport { useThrottledDailyEvent } from './useThrottledDailyEvent';\n\ntype FilterParticipantsFunction = (\n  p: ExtendedDailyParticipant,\n  index: number,\n  arr: ExtendedDailyParticipant[]\n) => boolean;\ntype SerializableFilterParticipants =\n  | 'local'\n  | 'remote'\n  | 'owner'\n  | 'record'\n  | 'screen';\ntype FilterParticipants =\n  | SerializableFilterParticipants\n  | FilterParticipantsFunction;\n\ntype SortParticipantsFunction = (\n  a: ExtendedDailyParticipant,\n  b: ExtendedDailyParticipant\n) => 1 | -1 | 0;\ntype SerializableSortParticipants =\n  | 'joined_at'\n  | 'session_id'\n  | 'user_id'\n  | 'user_name';\ntype SortParticipants = SerializableSortParticipants | SortParticipantsFunction;\n\n/**\n * Short-cut state selector for useParticipantIds({ filter: 'local' })\n */\nexport const participantIdsFilteredAndSortedState = equalSelectorFamily<\n  string[],\n  {\n    filter: SerializableFilterParticipants | null;\n    sort: SerializableSortParticipants | null;\n  }\n>({\n  key: RECOIL_PREFIX + 'participant-ids-filtered-sorted',\n  equals: customDeepEqual,\n  get:\n    ({ filter, sort }) =>\n    ({ get }) => {\n      const ids = get(participantIdsState);\n      return ids\n        .filter((id) => {\n          switch (filter) {\n            /**\n             * Simple boolean fields first.\n             */\n            case 'local':\n            case 'owner':\n            case 'record': {\n              return get(participantPropertyState({ id, property: filter }));\n            }\n            case 'remote': {\n              return !get(participantPropertyState({ id, property: 'local' }));\n            }\n            case 'screen': {\n              const [screenAudioState, screenVideoState] = get(\n                participantPropertiesState({\n                  id,\n                  properties: [\n                    'tracks.screenAudio.state',\n                    'tracks.screenVideo.state',\n                  ],\n                })\n              );\n              return (\n                !isTrackOff(screenAudioState) || !isTrackOff(screenVideoState)\n              );\n            }\n            default:\n              return true;\n          }\n        })\n        .sort((idA, idB) => {\n          switch (sort) {\n            case 'joined_at':\n            case 'session_id':\n            case 'user_id':\n            case 'user_name': {\n              const [aSort] = get(\n                participantPropertiesState({ id: idA, properties: [sort] })\n              );\n              const [bSort] = get(\n                participantPropertiesState({ id: idB, properties: [sort] })\n              );\n              if (aSort !== undefined || bSort !== undefined) {\n                if (aSort === undefined) return -1;\n                if (bSort === undefined) return 1;\n                if (aSort > bSort) return 1;\n                if (aSort < bSort) return -1;\n              }\n              return 0;\n            }\n            default:\n              return 0;\n          }\n        });\n    },\n});\n\ninterface UseParticipantIdsArgs {\n  filter?: FilterParticipants;\n  onActiveSpeakerChange?(ev: DailyEventObject<'active-speaker-change'>): void;\n  onParticipantJoined?(ev: DailyEventObject<'participant-joined'>): void;\n  onParticipantLeft?(ev: DailyEventObject<'participant-left'>): void;\n  onParticipantUpdated?(ev: DailyEventObject<'participant-updated'>): void;\n  sort?: SortParticipants;\n}\n\n/**\n * Returns a list of participant ids (= session_id).\n * The list can optionally be filtered and sorted, using the filter and sort options.\n */\nexport const useParticipantIds = ({\n  filter,\n  onActiveSpeakerChange,\n  onParticipantJoined,\n  onParticipantLeft,\n  onParticipantUpdated,\n  sort,\n}: UseParticipantIdsArgs = {}) => {\n  /**\n   * For instances of useParticipantIds with string-based filter and sort,\n   * we can immediately return the correct ids from Recoil's state.\n   */\n  const preFilteredSortedIds = useRecoilValue(\n    participantIdsFilteredAndSortedState({\n      filter: typeof filter === 'string' ? filter : null,\n      sort: typeof sort === 'string' ? sort : null,\n    })\n  );\n\n  const getCustomFilteredIds = useRecoilCallback(\n    ({ snapshot }) =>\n      () => {\n        if (\n          // Ignore if both filter and sort are not functions.\n          typeof filter !== 'function' &&\n          typeof sort !== 'function'\n        )\n          return [];\n\n        const participants: ExtendedDailyParticipant[] =\n          preFilteredSortedIds.map(\n            (id) =>\n              snapshot.getLoadable(participantState(id))\n                .contents as ExtendedDailyParticipant\n          );\n\n        return (\n          participants\n            // Make sure we don't accidentally try to filter/sort `null` participants\n            // This can happen when a participant's id is already present in store\n            // but the participant object is not stored, yet.\n            .filter(Boolean)\n            // Run custom filter, if it's a function. Otherwise don't filter any participants.\n            .filter(typeof filter === 'function' ? filter : () => true)\n            // Run custom sort, if it's a function. Otherwise don't sort.\n            .sort(typeof sort === 'function' ? sort : () => 0)\n            // Map back to session_id.\n            .map((p) => p.session_id)\n            // Filter any potential null/undefined ids.\n            // This shouldn't really happen, but better safe than sorry.\n            .filter(Boolean)\n        );\n      },\n    [filter, preFilteredSortedIds, sort]\n  );\n\n  const [customIds, setCustomIds] = useState<string[]>([]);\n\n  const maybeUpdateCustomIds = useCallback(() => {\n    const newIds = getCustomFilteredIds();\n    if (customDeepEqual(newIds, customIds)) return;\n    setCustomIds(newIds);\n  }, [customIds, getCustomFilteredIds]);\n\n  useEffect(() => {\n    maybeUpdateCustomIds();\n  }, [maybeUpdateCustomIds]);\n\n  useThrottledDailyEvent(\n    [\n      'participant-joined',\n      'participant-updated',\n      'active-speaker-change',\n      'participant-left',\n    ],\n    useCallback(\n      (evts) => {\n        if (!evts.length) return;\n        evts.forEach((ev) => {\n          switch (ev.action) {\n            case 'participant-joined':\n              onParticipantJoined?.(ev);\n              break;\n            case 'participant-updated':\n              onParticipantUpdated?.(ev);\n              break;\n            case 'active-speaker-change':\n              onActiveSpeakerChange?.(ev);\n              break;\n            case 'participant-left':\n              onParticipantLeft?.(ev);\n              break;\n          }\n        });\n        maybeUpdateCustomIds();\n      },\n      [\n        maybeUpdateCustomIds,\n        onActiveSpeakerChange,\n        onParticipantJoined,\n        onParticipantLeft,\n        onParticipantUpdated,\n      ]\n    )\n  );\n\n  const result =\n    typeof filter === 'function' || typeof sort === 'function'\n      ? customIds\n      : preFilteredSortedIds;\n\n  useDebugValue(result);\n\n  return result;\n};\n","import {\n  DailyCall,\n  DailyEventObjectNonFatalError,\n  DailyTrackState,\n} from '@daily-co/daily-js';\nimport { useCallback, useDebugValue } from 'react';\nimport { useRecoilValue } from 'recoil';\n\nimport { RECOIL_PREFIX } from '../lib/constants';\nimport { customDeepEqual } from '../lib/customDeepEqual';\nimport { equalSelector } from '../lib/recoil-custom';\nimport { Reconstruct } from '../types/Reconstruct';\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\nimport { participantIdsFilteredAndSortedState } from './useParticipantIds';\nimport { participantPropertyState } from './useParticipantProperty';\n\nexport interface ScreenShare {\n  local: boolean;\n  screenAudio: DailyTrackState;\n  screenVideo: DailyTrackState;\n  screenId: string;\n  session_id: string;\n}\n\nconst screenSharesState = equalSelector({\n  key: RECOIL_PREFIX + 'screen-shares',\n  equals: customDeepEqual,\n  get: ({ get }) => {\n    const screenIds = get(\n      participantIdsFilteredAndSortedState({ filter: 'screen', sort: null })\n    );\n    return screenIds.map<ScreenShare>((id) => {\n      return {\n        local: get(participantPropertyState({ id, property: 'local' })),\n        screenAudio: get(\n          participantPropertyState({ id, property: 'tracks.screenAudio' })\n        ),\n        screenVideo: get(\n          participantPropertyState({ id, property: 'tracks.screenVideo' })\n        ),\n        screenId: `${id}-screen`,\n        session_id: id,\n      };\n    });\n  },\n});\n\ntype DailyEventObjectScreenShareError = Reconstruct<\n  DailyEventObjectNonFatalError,\n  'type',\n  'screen-share-error'\n>;\n\ninterface UseScreenShareArgs {\n  onError?(ev: DailyEventObjectScreenShareError): void;\n  onLocalScreenShareStarted?(): void;\n  onLocalScreenShareStopped?(): void;\n}\n\n/**\n * Allows access to information about shared screens, and methods to start or stop a local screen share.\n */\nexport const useScreenShare = ({\n  onError,\n  onLocalScreenShareStarted,\n  onLocalScreenShareStopped,\n}: UseScreenShareArgs = {}) => {\n  const daily = useDaily();\n\n  const startScreenShare = useCallback(\n    (...args: Parameters<DailyCall['startScreenShare']>) => {\n      daily?.startScreenShare(...args);\n    },\n    [daily]\n  );\n\n  const stopScreenShare = useCallback(\n    (...args: Parameters<DailyCall['stopScreenShare']>) => {\n      daily?.stopScreenShare(...args);\n    },\n    [daily]\n  );\n\n  useDailyEvent(\n    'local-screen-share-started',\n    useCallback(\n      () => onLocalScreenShareStarted?.(),\n      [onLocalScreenShareStarted]\n    )\n  );\n  useDailyEvent(\n    'local-screen-share-stopped',\n    useCallback(\n      () => onLocalScreenShareStopped?.(),\n      [onLocalScreenShareStopped]\n    )\n  );\n  useDailyEvent(\n    'nonfatal-error',\n    useCallback(\n      (ev) => {\n        if (ev.type !== 'screen-share-error') return;\n        onError?.(ev as DailyEventObjectScreenShareError);\n      },\n      [onError]\n    )\n  );\n\n  const screens = useRecoilValue(screenSharesState);\n\n  const result = {\n    isSharingScreen: screens.some((s) => s.local),\n    screens,\n    startScreenShare,\n    stopScreenShare,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import { DailyParticipantTracks, DailyTrackState } from '@daily-co/daily-js';\nimport { useDebugValue } from 'react';\n\nimport { isTrackOff } from '../utils/isTrackOff';\nimport { useParticipantProperty } from './useParticipantProperty';\n\ntype MediaType = keyof DailyParticipantTracks;\n\nexport interface MediaTrackState extends DailyTrackState {\n  isOff: boolean;\n}\n\n/**\n * Returns a participant's track and state, based on the given MediaType.\n *\n * Equivalent to daily.participants()[participantId].tracks[type].\n *\n * @param participantId The participant's session_id.\n * @param type The track type. Default: \"video\"\n */\nexport const useMediaTrack = (\n  participantId: string,\n  type: MediaType = 'video'\n): MediaTrackState => {\n  const trackState = useParticipantProperty(participantId, `tracks.${type}`);\n\n  const result: MediaTrackState = trackState\n    ? {\n        ...trackState,\n        isOff: isTrackOff(trackState.state),\n      }\n    : {\n        isOff: true,\n        persistentTrack: undefined,\n        state: 'off',\n        subscribed: false,\n      };\n\n  useDebugValue(result);\n\n  return result;\n};\n","/**\n * Original source: https://github.com/jaredLunde/react-hook/blob/master/packages/merged-ref/src/index.tsx\n * Original author: Jared Lunde (https://github.com/jaredLunde)\n * Originally published under the MIT license: https://github.com/jaredLunde/react-hook/blob/master/LICENSE\n */\n\nimport React, { useCallback } from 'react';\n\nfunction useMergedRef<T>(...refs: React.Ref<T>[]): React.RefCallback<T> {\n  return useCallback(\n    (element: T) => {\n      for (let i = 0; i < refs.length; i++) {\n        const ref = refs[i];\n        if (typeof ref === 'function') ref(element);\n        else if (ref && typeof ref === 'object')\n          (ref as React.MutableRefObject<T>).current = element;\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    refs\n  );\n}\n\nexport default useMergedRef;\n","import React, { forwardRef, memo, useEffect, useRef } from 'react';\n\nimport { useMediaTrack } from '../hooks/useMediaTrack';\nimport useMergedRef from '../hooks/useMergedRef';\n\nexport interface DailyAudioPlayException {\n  name?: string;\n  message?: string;\n  sessionId: string;\n  target: HTMLAudioElement;\n  type: string;\n}\n\ninterface Props extends React.AudioHTMLAttributes<HTMLAudioElement> {\n  /**\n   * Callback to handle failed attempt to play audio.\n   */\n  onPlayFailed?(e: DailyAudioPlayException): void;\n  sessionId: string;\n  type?: 'audio' | 'screenAudio' | 'rmpAudio';\n}\n\nexport const DailyAudioTrack = memo(\n  forwardRef<HTMLAudioElement, Props>(\n    ({ onPlayFailed, sessionId, type = 'audio', ...props }, ref) => {\n      const audioEl = useRef<HTMLAudioElement>(null);\n      const audio = useMediaTrack(sessionId, type);\n      const audioRef = useMergedRef<HTMLAudioElement>(audioEl, ref);\n      const subscribedState = audio?.subscribed;\n\n      /**\n       * Setup audio tag.\n       */\n      useEffect(() => {\n        const audioTag = audioEl.current;\n        if (!audioTag || !audio?.persistentTrack) return;\n        let playTimeout: ReturnType<typeof setTimeout>;\n        const handleCanPlay = () => {\n          audioTag.play().catch((e) => {\n            onPlayFailed?.({\n              sessionId,\n              target: audioTag,\n              type,\n              message: e.message,\n              name: e.name,\n            });\n          });\n        };\n        const handlePlay = () => {\n          clearTimeout(playTimeout);\n        };\n        audioTag.addEventListener('canplay', handleCanPlay);\n        audioTag.addEventListener('play', handlePlay);\n        audioTag.srcObject = new MediaStream([audio?.persistentTrack]);\n\n        return () => {\n          audioTag?.removeEventListener('canplay', handleCanPlay);\n          audioTag?.removeEventListener('play', handlePlay);\n        };\n      }, [audio?.persistentTrack, onPlayFailed, sessionId, type]);\n\n      return (\n        <audio\n          autoPlay\n          playsInline\n          ref={audioRef}\n          {...props}\n          data-session-id={sessionId}\n          data-audio-type={type}\n          data-subscribed={subscribedState}\n        />\n      );\n    }\n  )\n);\nDailyAudioTrack.displayName = 'DailyAudioTrack';\n","import React, {\n  forwardRef,\n  memo,\n  useCallback,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from 'react';\nimport { useRecoilCallback } from 'recoil';\n\nimport { ExtendedDailyParticipant } from '../DailyParticipants';\nimport { useActiveSpeakerId } from '../hooks/useActiveSpeakerId';\nimport { useDaily } from '../hooks/useDaily';\nimport { useLocalSessionId } from '../hooks/useLocalSessionId';\nimport { useParticipantIds } from '../hooks/useParticipantIds';\nimport { participantPropertyState } from '../hooks/useParticipantProperty';\nimport { useScreenShare } from '../hooks/useScreenShare';\nimport { useThrottledDailyEvent } from '../hooks/useThrottledDailyEvent';\nimport { isTrackOff } from '../utils/isTrackOff';\nimport { DailyAudioPlayException, DailyAudioTrack } from './DailyAudioTrack';\n\ninterface Props {\n  /**\n   * When enabled and the call is configured for manual track subscriptions,\n   * DailyAudio will automatically subscribe to the active speaker's audio track.\n   */\n  autoSubscribeActiveSpeaker?: boolean;\n  /**\n   * Maximum amount of parallel speakers. Default: 5.\n   */\n  maxSpeakers?: number;\n  /**\n   * Callback to handle failed attempt to play audio.\n   */\n  onPlayFailed?(e: DailyAudioPlayException): void;\n  /**\n   * When enabled, plays audio from a local screenAudio track.\n   */\n  playLocalScreenAudio?: boolean;\n}\n\nexport interface DailyAudioHandle {\n  /**\n   * Returns all rendered audio elements.\n   */\n  getAllAudio(): HTMLAudioElement[];\n  /**\n   * Returns the audio element assigned to the current active speaker.\n   */\n  getActiveSpeakerAudio(): HTMLAudioElement | null;\n  /**\n   * Returns all rendered audio elements for rmpAudio tracks.\n   */\n  getRmpAudio(): HTMLAudioElement[];\n  /**\n   * Returns all rendered audio elements for screenAudio tracks.\n   */\n  getScreenAudio(): HTMLAudioElement[];\n  /**\n   * Returns the audio track for the given sessionId.\n   */\n  getAudioBySessionId(sessionId: string): HTMLAudioElement | null;\n  /**\n   * Returns the rmpAudio track for the given sessionId.\n   */\n  getRmpAudioBySessionId(sessionId: string): HTMLAudioElement | null;\n  /**\n   * Returns the screenAudio track for the given sessionId.\n   */\n  getScreenAudioBySessionId(sessionId: string): HTMLAudioElement | null;\n}\n\nexport const DailyAudio = memo(\n  forwardRef<DailyAudioHandle, Props>(\n    (\n      {\n        autoSubscribeActiveSpeaker = false,\n        maxSpeakers = 5,\n        onPlayFailed,\n        playLocalScreenAudio = false,\n      },\n      ref\n    ) => {\n      const daily = useDaily();\n      const [speakers, setSpeakers] = useState<string[]>(\n        new Array(maxSpeakers).fill('')\n      );\n      const { screens } = useScreenShare();\n      const localSessionId = useLocalSessionId();\n      const activeSpeakerId = useActiveSpeakerId({\n        ignoreLocal: true,\n      });\n\n      const containerRef = useRef<HTMLDivElement>(null);\n      useImperativeHandle(\n        ref,\n        () => ({\n          getActiveSpeakerAudio: () => {\n            return (\n              containerRef.current?.querySelector(\n                `audio[data-session-id=\"${activeSpeakerId}\"][data-audio-type=\"audio\"]`\n              ) ?? null\n            );\n          },\n          getAllAudio: () => {\n            return Array.from(\n              containerRef.current?.querySelectorAll('audio') ?? []\n            );\n          },\n          getAudioBySessionId: (id) => {\n            return (\n              containerRef.current?.querySelector(\n                `audio[data-session-id=\"${id}\"][data-audio-type=\"audio\"]`\n              ) ?? null\n            );\n          },\n          getRmpAudio: () => {\n            return Array.from(\n              containerRef.current?.querySelectorAll(\n                'audio[data-audio-type=\"rmpAudio\"]'\n              ) ?? []\n            );\n          },\n          getScreenAudio: () => {\n            return Array.from(\n              containerRef.current?.querySelectorAll(\n                'audio[data-audio-type=\"screenAudio\"]'\n              ) ?? []\n            );\n          },\n          getRmpAudioBySessionId: (id) => {\n            return (\n              containerRef.current?.querySelector(\n                `audio[data-session-id=\"${id}\"][data-audio-type=\"rmpAudio\"]`\n              ) ?? null\n            );\n          },\n          getScreenAudioBySessionId: (id) => {\n            return (\n              containerRef.current?.querySelector(\n                `audio[data-session-id=\"${id}\"][data-audio-type=\"screenAudio\"]`\n              ) ?? null\n            );\n          },\n        }),\n        [activeSpeakerId]\n      );\n\n      const assignSpeaker = useRecoilCallback(\n        ({ snapshot }) =>\n          async (sessionId: string) => {\n            /**\n             * Only consider remote participants with subscribed or staged audio.\n             */\n            const subscribedParticipants = Object.values(\n              daily?.participants() ?? {}\n            ).filter((p) => !p.local && Boolean(p.tracks.audio.subscribed));\n\n            const isSubscribed = (id: string) =>\n              subscribedParticipants.some((p) => p.session_id === id);\n\n            if (!isSubscribed(sessionId)) {\n              if (\n                daily &&\n                !daily.isDestroyed() &&\n                autoSubscribeActiveSpeaker &&\n                !daily.subscribeToTracksAutomatically()\n              ) {\n                daily.updateParticipant(sessionId, {\n                  setSubscribedTracks: {\n                    audio: true,\n                  },\n                });\n              } else {\n                return;\n              }\n            }\n\n            setSpeakers((prevSpeakers) => {\n              // New speaker is already present\n              if (prevSpeakers.includes(sessionId)) return prevSpeakers;\n\n              // Try to find a free slot: either unassigned or unsubscribed\n              const freeSlotCheck = (id: string) => !id || !isSubscribed(id);\n              if (prevSpeakers.some(freeSlotCheck)) {\n                const idx = prevSpeakers.findIndex(freeSlotCheck);\n                prevSpeakers[idx] = sessionId;\n                return [...prevSpeakers];\n              }\n\n              // From here on we can assume that all assigned audio tracks are subscribed.\n\n              // Try to find muted recent speaker\n              const mutedIdx = prevSpeakers.findIndex((id) =>\n                subscribedParticipants.some(\n                  (p) => p.session_id === id && isTrackOff(p.tracks.audio.state)\n                )\n              );\n              if (mutedIdx >= 0) {\n                prevSpeakers[mutedIdx] = sessionId;\n                return [...prevSpeakers];\n              }\n\n              // Find least recent non-active speaker and replace with new speaker\n              const speakerObjects = subscribedParticipants\n                .filter(\n                  (p) =>\n                    // Only consider participants currently assigned to speaker slots\n                    prevSpeakers.includes(p.session_id) &&\n                    // Don't replace current active participant, to avoid audio drop-outs\n                    p.session_id !== activeSpeakerId\n                )\n                .sort((a, b) => {\n                  const lastActiveA =\n                    snapshot.getLoadable(\n                      participantPropertyState({\n                        id: a.session_id,\n                        property: 'last_active',\n                      })\n                    ).contents ?? new Date('1970-01-01');\n                  const lastActiveB =\n                    snapshot.getLoadable(\n                      participantPropertyState({\n                        id: b.session_id,\n                        property: 'last_active',\n                      })\n                    ).contents ?? new Date('1970-01-01');\n                  if (lastActiveA > lastActiveB) return 1;\n                  if (lastActiveA < lastActiveB) return -1;\n                  return 0;\n                });\n\n              // No previous speaker in call anymore. Assign first free slot.\n              if (!speakerObjects.length) {\n                // Don't replace the active speaker. Instead find first non-active speaker slot.\n                const replaceIdx = prevSpeakers.findIndex(\n                  (id) => id !== activeSpeakerId\n                );\n                prevSpeakers[replaceIdx] = sessionId;\n                return [...prevSpeakers];\n              }\n\n              // Replace least recent speaker with new speaker\n              const replaceIdx = prevSpeakers.indexOf(\n                speakerObjects[0]?.session_id\n              );\n              prevSpeakers[replaceIdx] = sessionId;\n              return [...prevSpeakers];\n            });\n          },\n        [activeSpeakerId, autoSubscribeActiveSpeaker, daily]\n      );\n\n      /**\n       * Unassigns speaker from speaker slot, e.g. because participant left the call.\n       */\n      const removeSpeaker = useCallback((sessionId: string) => {\n        setSpeakers((prevSpeakers) => {\n          if (!prevSpeakers.includes(sessionId)) return prevSpeakers;\n          const newSpeakers = [...prevSpeakers];\n          const idx = newSpeakers.indexOf(sessionId);\n          newSpeakers[idx] = '';\n          return newSpeakers;\n        });\n      }, []);\n\n      useThrottledDailyEvent(\n        ['active-speaker-change', 'track-started', 'participant-left'],\n        useCallback(\n          (evts) => {\n            evts.forEach((ev) => {\n              switch (ev.action) {\n                case 'active-speaker-change':\n                  if (ev.activeSpeaker.peerId === localSessionId) return;\n                  assignSpeaker(ev.activeSpeaker.peerId);\n                  break;\n                case 'track-started':\n                  if (\n                    ev.track.kind === 'audio' &&\n                    ev.participant &&\n                    !ev.participant.local\n                  ) {\n                    assignSpeaker(ev.participant.session_id);\n                  }\n                  break;\n                case 'participant-left':\n                  removeSpeaker(ev.participant.session_id);\n                  break;\n              }\n            });\n          },\n          [assignSpeaker, localSessionId, removeSpeaker]\n        ),\n        200\n      );\n\n      const rmpAudioIds = useParticipantIds({\n        filter: useCallback(\n          (p: ExtendedDailyParticipant) => Boolean(p?.tracks?.rmpAudio),\n          []\n        ),\n      });\n\n      return (\n        <div ref={containerRef}>\n          {speakers.map((sessionId, idx) => (\n            <DailyAudioTrack\n              key={`speaker-slot-${idx}`}\n              onPlayFailed={onPlayFailed}\n              sessionId={sessionId}\n              type=\"audio\"\n            />\n          ))}\n          {screens\n            .filter((screen) => (playLocalScreenAudio ? true : !screen.local))\n            .map((screen) => (\n              <DailyAudioTrack\n                key={screen.screenId}\n                onPlayFailed={onPlayFailed}\n                sessionId={screen.session_id}\n                type=\"screenAudio\"\n              />\n            ))}\n          {rmpAudioIds.map((id) => (\n            <DailyAudioTrack\n              key={`${id}-rmp`}\n              onPlayFailed={onPlayFailed}\n              sessionId={id}\n              type=\"rmpAudio\"\n            />\n          ))}\n        </div>\n      );\n    }\n  )\n);\nDailyAudio.displayName = 'DailyAudio';\n","import React, { forwardRef, useEffect, useMemo, useRef } from 'react';\n\nimport { useLocalSessionId } from '../hooks/useLocalSessionId';\nimport { useMediaTrack } from '../hooks/useMediaTrack';\nimport useMergedRef from '../hooks/useMergedRef';\nimport { useParticipantProperty } from '../hooks/useParticipantProperty';\n\ninterface DailyVideoDimensions {\n  aspectRatio: number;\n  height: number;\n  width: number;\n}\n\ninterface Props extends React.VideoHTMLAttributes<HTMLVideoElement> {\n  /**\n   * For local user-facing camera streams, we'll automatically mirror the video.\n   */\n  automirror?: boolean;\n  /**\n   * Defines whether the video should be fully contained or cover the box. Default: 'contain'.\n   */\n  fit?: 'contain' | 'cover';\n  /**\n   * Forces the video to be mirrored, if set.\n   */\n  mirror?: boolean;\n  /**\n   * Optional styles to apply, when video is playable.\n   */\n  playableStyle?: React.CSSProperties;\n  /**\n   * Optional callback, which is triggered whenever the video's rendered width or height changes.\n   * Returns the video's native width, height and aspectRatio.\n   */\n  onResize?(dimensions: DailyVideoDimensions): void;\n  /**\n   * Identifies the participant for which a video stream should be rendered.\n   */\n  sessionId: string;\n  /**\n   * Defines the track type being used.\n   */\n  type: 'video' | 'screenVideo' | 'rmpVideo';\n}\n\nexport const DailyVideo = forwardRef<HTMLVideoElement, Props>(\n  function DailyVideo(\n    {\n      automirror,\n      fit = 'contain',\n      mirror,\n      onResize,\n      playableStyle = {},\n      sessionId,\n      style = {},\n      type = 'video',\n      ...props\n    },\n    ref\n  ) {\n    const localSessionId = useLocalSessionId();\n    const isLocal = localSessionId === sessionId;\n    const isScreen = type === 'screenVideo';\n    const isLocalCam = isLocal && !isScreen;\n\n    const videoEl = useRef<HTMLVideoElement>(null);\n    const videoRef = useMergedRef<HTMLVideoElement>(videoEl, ref);\n\n    const videoState = useMediaTrack(sessionId, type);\n    const videoTrack = videoState.persistentTrack;\n    /**\n     * Considered as playable video:\n     * - local cam feed\n     * - any screen share\n     * - remote cam feed that is subscribed and reported as playable\n     */\n    const isPlayable = isLocalCam || isScreen || !videoState.isOff;\n    const trackState = useParticipantProperty(sessionId, `tracks.${type}`);\n    const subscribedState = trackState?.subscribed;\n\n    /**\n     * Determine if video needs to be mirrored.\n     */\n    const isMirrored = useMemo(() => {\n      if (typeof mirror === 'boolean') return mirror;\n      if (!automirror) return false;\n      if (!videoTrack) return isLocalCam;\n\n      const videoTrackSettings = videoTrack.getSettings();\n      const isUsersFrontCamera =\n        'facingMode' in videoTrackSettings\n          ? isLocalCam && videoTrackSettings.facingMode === 'user'\n          : isLocalCam;\n      // only apply mirror effect to user facing camera\n      return isUsersFrontCamera;\n    }, [automirror, isLocalCam, mirror, videoTrack]);\n\n    /**\n     * Handle canplay & picture-in-picture events.\n     */\n    useEffect(function setupVideoEvents() {\n      const video = videoEl.current;\n      if (!video) return;\n\n      const playVideo = () => {\n        const promise = video.play();\n        if (promise !== undefined) {\n          promise\n            .then(() => {\n              // All good, playback started.\n              video.controls = false;\n            })\n            .catch((error) => {\n              // Auto-play was prevented. Show video controls, so user can play video manually.\n              video.controls = true;\n              console.warn('Failed to play video', error);\n            });\n        }\n      };\n\n      const handleCanPlay = () => {\n        if (!video.paused) return;\n        playVideo();\n      };\n      const handleEnterPIP = () => {\n        video.style.transform = 'scale(1)';\n      };\n      const handleLeavePIP = () => {\n        video.style.transform = '';\n        setTimeout(() => {\n          if (video.paused) playVideo();\n        }, 100);\n      };\n      const handleVisibilityChange = () => {\n        if (document.visibilityState === 'hidden') return;\n        if (!video.paused) return;\n        playVideo();\n      };\n      video.addEventListener('canplay', handleCanPlay);\n      video.addEventListener('enterpictureinpicture', handleEnterPIP);\n      video.addEventListener('leavepictureinpicture', handleLeavePIP);\n\n      // Videos can be paused if media was played in another app on iOS.\n      // Resuming here, when returning back to Daily call.\n      document.addEventListener('visibilitychange', handleVisibilityChange);\n      return () => {\n        video.removeEventListener('canplay', handleCanPlay);\n        video.removeEventListener('enterpictureinpicture', handleEnterPIP);\n        video.removeEventListener('leavepictureinpicture', handleLeavePIP);\n        document.removeEventListener(\n          'visibilitychange',\n          handleVisibilityChange\n        );\n      };\n    }, []);\n\n    /**\n     * Update srcObject.\n     */\n    useEffect(\n      function updateSrcObject() {\n        const video = videoEl.current;\n        if (!video || !videoTrack) return;\n        video.srcObject = new MediaStream([videoTrack]);\n        video.load();\n        return () => {\n          // clean up when unmounted\n          video.srcObject = null;\n          video.load();\n        };\n      },\n      [videoTrack, videoTrack?.id]\n    );\n\n    /**\n     * Add optional event listener for resize event so the parent component\n     * can know the video's native aspect ratio.\n     */\n    useEffect(\n      function reportVideoDimensions() {\n        const video = videoEl.current;\n        if (!onResize || !video) return;\n\n        let frame: ReturnType<typeof requestAnimationFrame>;\n        function handleResize() {\n          if (frame) cancelAnimationFrame(frame);\n          frame = requestAnimationFrame(() => {\n            const video = videoEl.current;\n            if (!video || document.hidden) return;\n            const videoWidth = video.videoWidth;\n            const videoHeight = video.videoHeight;\n            if (videoWidth && videoHeight) {\n              onResize?.({\n                aspectRatio: videoWidth / videoHeight,\n                height: videoHeight,\n                width: videoWidth,\n              });\n            }\n          });\n        }\n\n        handleResize();\n        video.addEventListener('loadedmetadata', handleResize);\n        video.addEventListener('resize', handleResize);\n\n        return () => {\n          if (frame) cancelAnimationFrame(frame);\n          video.removeEventListener('loadedmetadata', handleResize);\n          video.removeEventListener('resize', handleResize);\n        };\n      },\n      [onResize]\n    );\n\n    return (\n      <video\n        autoPlay\n        muted\n        playsInline\n        ref={videoRef}\n        data-local={isLocal}\n        // Only set data-mirrored and data-playable when true\n        data-mirrored={isMirrored || undefined}\n        data-playable={isPlayable || undefined}\n        data-session-id={sessionId}\n        data-subscribed={subscribedState}\n        data-video-type={type}\n        style={{\n          objectFit: fit,\n          transform: isMirrored ? 'scale(-1, 1)' : '',\n          ...style,\n          ...(isPlayable ? playableStyle : {}),\n        }}\n        {...props}\n      />\n    );\n  }\n);\nDailyVideo.displayName = 'DailyVideo';\n","import { createContext } from 'react';\n\ninterface DevicesContextValue {\n  refreshDevices(): Promise<void>;\n}\n\nexport const DailyDevicesContext = createContext<DevicesContextValue>({\n  refreshDevices: () => Promise.resolve(),\n});\n","import {\n  DailyCameraErrorObject,\n  DailyCameraErrorType,\n} from '@daily-co/daily-js';\nimport React, { useCallback } from 'react';\nimport { atom, useRecoilCallback } from 'recoil';\n\nimport { DailyDevicesContext } from './DailyDevicesContext';\nimport { useDaily } from './hooks/useDaily';\nimport { useDailyEvent } from './hooks/useDailyEvent';\nimport { RECOIL_PREFIX } from './lib/constants';\n\ntype GeneralState =\n  | 'idle'\n  | 'pending'\n  | 'not-supported'\n  | 'granted'\n  | 'blocked'\n  | 'in-use'\n  | 'not-found'\n  | 'constraints-invalid'\n  | 'constraints-none-specified'\n  | 'undefined-mediadevices'\n  | 'unknown';\n\ntype DeviceState = 'granted' | 'in-use';\nexport interface StatefulDevice {\n  device: MediaDeviceInfo;\n  selected: boolean;\n  state: DeviceState;\n}\n\nexport const generalCameraState = atom<GeneralState>({\n  key: RECOIL_PREFIX + 'general-camera-state',\n  default: 'idle',\n});\nexport const generalMicrophoneState = atom<GeneralState>({\n  key: RECOIL_PREFIX + 'general-microphone-state',\n  default: 'idle',\n});\nexport const cameraDevicesState = atom<StatefulDevice[]>({\n  key: RECOIL_PREFIX + 'camera-devices',\n  default: [],\n});\nexport const microphoneDevicesState = atom<StatefulDevice[]>({\n  key: RECOIL_PREFIX + 'microphone-devices',\n  default: [],\n});\nexport const speakerDevicesState = atom<StatefulDevice[]>({\n  key: RECOIL_PREFIX + 'speaker-devices',\n  default: [],\n});\nexport const lastCameraErrorState =\n  atom<DailyCameraErrorObject<DailyCameraErrorType> | null>({\n    key: RECOIL_PREFIX + 'last-camera-error',\n    default: null,\n  });\n\nexport const DailyDevices: React.FC<React.PropsWithChildren<unknown>> = ({\n  children,\n}) => {\n  const daily = useDaily();\n\n  /**\n   * Refreshes list of available devices using enumerateDevices.\n   * Previous device states are kept in place, otherwise states are initialized as 'granted'.\n   */\n  const refreshDevices = useRecoilCallback(\n    ({ transact_UNSTABLE }) =>\n      async () => {\n        /**\n         * Check for legacy browsers.\n         */\n        if (\n          typeof navigator?.mediaDevices?.getUserMedia === 'undefined' ||\n          typeof navigator?.mediaDevices?.enumerateDevices === 'undefined'\n        ) {\n          transact_UNSTABLE(({ set }) => {\n            set(generalCameraState, 'not-supported');\n            set(generalMicrophoneState, 'not-supported');\n          });\n          return;\n        }\n\n        if (!daily) return;\n\n        try {\n          const { devices } = await daily.enumerateDevices();\n          /**\n           * Filter out \"empty\" devices for when device access has not been granted (yet).\n           */\n          const cams = devices.filter(\n            (d) => d.kind === 'videoinput' && d.deviceId !== ''\n          );\n          const mics = devices.filter(\n            (d) => d.kind === 'audioinput' && d.deviceId !== ''\n          );\n          const speakers = devices.filter(\n            (d) => d.kind === 'audiooutput' && d.deviceId !== ''\n          );\n          const { camera, mic, speaker } = await daily.getInputDevices();\n\n          const mapDevice = (\n            device: {} | MediaDeviceInfo,\n            d: MediaDeviceInfo,\n            prevDevices: StatefulDevice[]\n          ) => ({\n            device: d,\n            selected: 'deviceId' in device && d.deviceId === device.deviceId,\n            state:\n              prevDevices.find((p) => p.device.deviceId === d.deviceId)\n                ?.state ?? 'granted',\n          });\n          const sortDeviceByLabel = (a: StatefulDevice, b: StatefulDevice) => {\n            if (a.device.deviceId === 'default') return -1;\n            if (b.device.deviceId === 'default') return 1;\n            if (a.device.label < b.device.label) return -1;\n            if (a.device.label > b.device.label) return 1;\n            return 0;\n          };\n\n          transact_UNSTABLE(({ set }) => {\n            set(cameraDevicesState, (prevCams) =>\n              cams\n                .filter(Boolean)\n                .map<StatefulDevice>((d) => mapDevice(camera, d, prevCams))\n                .sort(sortDeviceByLabel)\n            );\n            set(microphoneDevicesState, (prevMics) =>\n              mics\n                .filter(Boolean)\n                .map<StatefulDevice>((d) => mapDevice(mic, d, prevMics))\n                .sort(sortDeviceByLabel)\n            );\n            set(speakerDevicesState, (prevSpeakers) =>\n              speakers\n                .filter(Boolean)\n                .map<StatefulDevice>((d) => mapDevice(speaker, d, prevSpeakers))\n                .sort(sortDeviceByLabel)\n            );\n          });\n        } catch (e) {\n          transact_UNSTABLE(({ set }) => {\n            set(generalCameraState, 'not-supported');\n            set(generalMicrophoneState, 'not-supported');\n          });\n        }\n      },\n    [daily]\n  );\n\n  /**\n   * Updates general and specific device states, based on blocked status.\n   */\n  const updateDeviceStates = useRecoilCallback(\n    ({ set, snapshot, transact_UNSTABLE }) =>\n      async () => {\n        if (!daily) return;\n\n        const currentCamState = await snapshot.getPromise(generalCameraState);\n        const currentMicState = await snapshot.getPromise(\n          generalMicrophoneState\n        );\n\n        const participants = daily.participants();\n        // Guard against potentially uninitialized local participant\n        if (!participants.local) return;\n\n        const { tracks } = participants.local;\n\n        let camPermissionState: PermissionState = 'prompt';\n        let micPermissionState: PermissionState = 'prompt';\n        if (navigator.permissions) {\n          try {\n            const camPermission = await navigator.permissions.query({\n              // @ts-ignore\n              name: 'camera',\n            });\n            camPermissionState = camPermission.state;\n            const micPermission = await navigator.permissions.query({\n              // @ts-ignore\n              name: 'microphone',\n            });\n            micPermissionState = micPermission.state;\n          } catch {\n            // Permissions query not available\n          }\n        }\n\n        const awaitingCamAccess =\n          camPermissionState === 'prompt' &&\n          ['idle', 'pending'].includes(currentCamState) &&\n          tracks.video.state === 'interrupted' &&\n          !tracks.video.persistentTrack;\n        const initialCamOff =\n          ['idle', 'pending'].includes(currentCamState) &&\n          !tracks.video.persistentTrack &&\n          Boolean(tracks.video.off?.byUser);\n        const awaitingMicAccess =\n          micPermissionState === 'prompt' &&\n          ['idle', 'pending'].includes(currentMicState) &&\n          tracks.audio.state === 'interrupted' &&\n          !tracks.audio.persistentTrack;\n        const initialMicOff =\n          ['idle', 'pending'].includes(currentMicState) &&\n          !tracks.audio.persistentTrack &&\n          Boolean(tracks.audio.off?.byUser);\n\n        if (tracks.audio?.blocked?.byDeviceInUse) {\n          transact_UNSTABLE(({ set }) => {\n            set(generalMicrophoneState, 'in-use');\n            set(microphoneDevicesState, (mics) =>\n              mics.map<StatefulDevice>((m) =>\n                m.selected ? { ...m, state: 'in-use' } : m\n              )\n            );\n          });\n        } else if (tracks.audio?.blocked?.byDeviceMissing) {\n          set(generalMicrophoneState, 'not-found');\n        } else if (\n          tracks.audio?.blocked?.byPermissions ||\n          micPermissionState === 'denied'\n        ) {\n          set(generalMicrophoneState, 'blocked');\n        } else if (awaitingMicAccess) {\n          set(generalMicrophoneState, 'pending');\n        } else if (initialMicOff) {\n          set(generalMicrophoneState, 'idle');\n        } else {\n          transact_UNSTABLE(({ set }) => {\n            set(generalMicrophoneState, 'granted');\n            set(microphoneDevicesState, (mics) =>\n              mics.map<StatefulDevice>((m) =>\n                m.selected ? { ...m, state: 'granted' } : m\n              )\n            );\n          });\n        }\n\n        if (tracks.video?.blocked?.byDeviceInUse) {\n          transact_UNSTABLE(({ set }) => {\n            set(generalCameraState, 'in-use');\n            set(cameraDevicesState, (cams) =>\n              cams.map<StatefulDevice>((m) =>\n                m.selected ? { ...m, state: 'in-use' } : m\n              )\n            );\n          });\n        } else if (tracks.video?.blocked?.byDeviceMissing) {\n          set(generalCameraState, 'not-found');\n        } else if (\n          tracks.video?.blocked?.byPermissions ||\n          camPermissionState === 'denied'\n        ) {\n          set(generalCameraState, 'blocked');\n        } else if (awaitingCamAccess) {\n          set(generalCameraState, 'pending');\n        } else if (initialCamOff) {\n          set(generalCameraState, 'idle');\n        } else {\n          transact_UNSTABLE(({ set }) => {\n            set(generalCameraState, 'granted');\n            set(cameraDevicesState, (cams) =>\n              cams.map<StatefulDevice>((m) =>\n                m.selected ? { ...m, state: 'granted' } : m\n              )\n            );\n          });\n        }\n        refreshDevices();\n      },\n    [daily, refreshDevices]\n  );\n\n  useDailyEvent(\n    'participant-updated',\n    useCallback(\n      (ev) => {\n        if (!ev.participant.local) return;\n        updateDeviceStates();\n      },\n      [updateDeviceStates]\n    )\n  );\n\n  useDailyEvent('available-devices-updated', refreshDevices);\n  useDailyEvent('selected-devices-updated', refreshDevices);\n\n  useDailyEvent(\n    'camera-error',\n    useRecoilCallback(\n      ({ transact_UNSTABLE }) =>\n        (ev) => {\n          transact_UNSTABLE(({ set }) => {\n            set(lastCameraErrorState, ev.error);\n            switch (ev.error?.type) {\n              case 'cam-in-use':\n                set(generalCameraState, 'in-use');\n                break;\n              case 'mic-in-use':\n                set(generalMicrophoneState, 'in-use');\n                break;\n              case 'cam-mic-in-use':\n                set(generalCameraState, 'in-use');\n                set(generalMicrophoneState, 'in-use');\n                break;\n              case 'not-found':\n                if (ev.error?.missingMedia.includes('video'))\n                  set(generalCameraState, 'not-found');\n                if (ev.error?.missingMedia.includes('audio'))\n                  set(generalMicrophoneState, 'not-found');\n                break;\n              case 'permissions':\n                if (ev.error?.blockedMedia.includes('video'))\n                  set(generalCameraState, 'blocked');\n                if (ev.error?.blockedMedia.includes('audio'))\n                  set(generalMicrophoneState, 'blocked');\n                break;\n              case 'constraints':\n                if (ev.error?.reason === 'invalid') {\n                  set(generalCameraState, 'constraints-invalid');\n                  set(generalMicrophoneState, 'constraints-invalid');\n                } else if (ev.error?.reason === 'none-specified') {\n                  set(generalCameraState, 'constraints-none-specified');\n                  set(generalMicrophoneState, 'constraints-none-specified');\n                }\n                break;\n              case 'undefined-mediadevices':\n                set(generalCameraState, 'undefined-mediadevices');\n                set(generalMicrophoneState, 'undefined-mediadevices');\n                break;\n              case 'unknown':\n              default:\n                set(generalCameraState, 'unknown');\n                set(generalMicrophoneState, 'unknown');\n                break;\n            }\n          });\n        },\n      []\n    )\n  );\n\n  /**\n   * Update all device state, when camera is started.\n   */\n  useDailyEvent(\n    'started-camera',\n    useRecoilCallback(\n      ({ transact_UNSTABLE }) =>\n        () => {\n          transact_UNSTABLE(({ set }) => {\n            set(generalCameraState, 'granted');\n            set(generalMicrophoneState, 'granted');\n          });\n          updateDeviceStates();\n        },\n      [updateDeviceStates]\n    )\n  );\n\n  return (\n    <DailyDevicesContext.Provider value={{ refreshDevices }}>\n      {children}\n    </DailyDevicesContext.Provider>\n  );\n};\n","import { DailyStreamingLayoutConfig } from '@daily-co/daily-js';\nimport React from 'react';\nimport { atom, useRecoilCallback } from 'recoil';\n\nimport { useDailyEvent } from './hooks/useDailyEvent';\nimport { RECOIL_PREFIX } from './lib/constants';\n\ninterface LiveStreamingState {\n  errorMsg?: string;\n  isLiveStreaming: boolean;\n  layout?: DailyStreamingLayoutConfig;\n}\n\nexport const liveStreamingState = atom<LiveStreamingState>({\n  key: RECOIL_PREFIX + 'live-streaming',\n  default: {\n    errorMsg: undefined,\n    isLiveStreaming: false,\n    layout: undefined,\n  },\n});\n\nexport const DailyLiveStreaming: React.FC<React.PropsWithChildren<unknown>> = ({\n  children,\n}) => {\n  useDailyEvent(\n    'live-streaming-started',\n    useRecoilCallback(\n      ({ set }) =>\n        (ev) => {\n          set(liveStreamingState, {\n            isLiveStreaming: true,\n            layout: ev?.layout,\n          });\n        },\n      []\n    )\n  );\n\n  useDailyEvent(\n    'live-streaming-stopped',\n    useRecoilCallback(\n      ({ set }) =>\n        () => {\n          set(liveStreamingState, (prevState) => ({\n            ...prevState,\n            isLiveStreaming: false,\n            layout: undefined,\n          }));\n        },\n      []\n    )\n  );\n\n  useDailyEvent(\n    'live-streaming-error',\n    useRecoilCallback(\n      ({ set }) =>\n        (ev) => {\n          set(liveStreamingState, (prevState) => ({\n            ...prevState,\n            errorMsg: ev.errorMsg,\n          }));\n        },\n      []\n    )\n  );\n\n  useDailyEvent(\n    'left-meeting',\n    useRecoilCallback(\n      ({ reset }) =>\n        () => {\n          reset(liveStreamingState);\n        },\n      []\n    )\n  );\n\n  return <>{children}</>;\n};\n","import {\n  DailyEventObjectFatalError,\n  DailyEventObjectNonFatalError,\n  DailyMeetingSessionState,\n  DailyMeetingState,\n} from '@daily-co/daily-js';\nimport React from 'react';\nimport { atom, useRecoilCallback } from 'recoil';\n\nimport { useDaily } from './hooks/useDaily';\nimport { useDailyEvent } from './hooks/useDailyEvent';\nimport { RECOIL_PREFIX } from './lib/constants';\n\nexport const meetingStateState = atom<DailyMeetingState>({\n  key: RECOIL_PREFIX + 'meeting-state',\n  default: 'new',\n});\n\nexport const meetingErrorState = atom<DailyEventObjectFatalError | null>({\n  key: RECOIL_PREFIX + 'meeting-error',\n  default: null,\n});\n\nexport const nonFatalErrorState = atom<DailyEventObjectNonFatalError | null>({\n  key: RECOIL_PREFIX + 'non-fatal-error',\n  default: null,\n});\n\nexport const meetingSessionDataState = atom<DailyMeetingSessionState>({\n  key: 'meeting-session-data',\n  default: {\n    data: undefined,\n    topology: 'none',\n  },\n});\n\nexport const DailyMeeting: React.FC<React.PropsWithChildren<{}>> = ({\n  children,\n}) => {\n  const daily = useDaily();\n\n  /**\n   * Updates meeting state.\n   */\n  const updateMeetingState = useRecoilCallback(\n    ({ set }) =>\n      () => {\n        if (!daily) return;\n        const meetingState = daily.meetingState();\n        set(meetingStateState, meetingState);\n        return meetingState;\n      },\n    [daily]\n  );\n\n  useDailyEvent('loading', updateMeetingState);\n  useDailyEvent('loaded', updateMeetingState);\n  useDailyEvent('joining-meeting', updateMeetingState);\n  useDailyEvent('joined-meeting', updateMeetingState);\n  useDailyEvent('left-meeting', updateMeetingState);\n  useDailyEvent(\n    'error',\n    useRecoilCallback(\n      ({ set }) =>\n        (ev) => {\n          set(meetingErrorState, ev);\n          updateMeetingState();\n        },\n      [updateMeetingState]\n    )\n  );\n  useDailyEvent(\n    'nonfatal-error',\n    useRecoilCallback(\n      ({ set }) =>\n        (ev) => {\n          set(nonFatalErrorState, ev);\n        },\n      []\n    )\n  );\n\n  /**\n   * Updates meeting session state.\n   */\n  const initMeetingSessionState = useRecoilCallback(\n    ({ set }) =>\n      () => {\n        if (!daily) return;\n        set(meetingSessionDataState, daily.meetingSessionState());\n      },\n    [daily]\n  );\n\n  /**\n   * Initialize state when joined meeting or setting up the hook.\n   */\n  useDailyEvent('joined-meeting', initMeetingSessionState);\n\n  /**\n   * Update Recoil state whenever meeting session state is updated.\n   */\n  useDailyEvent(\n    'meeting-session-state-updated',\n    useRecoilCallback(\n      ({ set }) =>\n        (ev) => {\n          set(meetingSessionDataState, ev.meetingSessionState);\n        },\n      []\n    )\n  );\n\n  /**\n   * Reset Recoil state when meeting ends.\n   */\n  useDailyEvent(\n    'left-meeting',\n    useRecoilCallback(\n      ({ reset }) =>\n        () => {\n          reset(meetingSessionDataState);\n        },\n      []\n    )\n  );\n\n  /**\n   * Reset Recoil state when call instance is destroyed.\n   */\n  useDailyEvent(\n    'call-instance-destroyed',\n    useRecoilCallback(\n      ({ transact_UNSTABLE }) =>\n        () => {\n          transact_UNSTABLE(({ reset }) => {\n            reset(meetingStateState);\n            reset(meetingErrorState);\n            reset(nonFatalErrorState);\n            reset(meetingSessionDataState);\n          });\n        },\n      []\n    )\n  );\n\n  return <>{children}</>;\n};\n","import { DailyNetworkStats, DailyNetworkTopology } from '@daily-co/daily-js';\nimport React, { useEffect } from 'react';\nimport { atom, useRecoilCallback, useRecoilValue } from 'recoil';\n\nimport { useDaily } from './hooks/useDaily';\nimport { useDailyEvent } from './hooks/useDailyEvent';\nimport { RECOIL_PREFIX } from './lib/constants';\n\nexport const topologyState = atom<DailyNetworkTopology | 'none'>({\n  key: RECOIL_PREFIX + 'topology',\n  default: 'none',\n});\nexport const networkQualityState = atom<DailyNetworkStats['quality']>({\n  key: RECOIL_PREFIX + 'networkQuality',\n  default: 100,\n});\nexport const networkThresholdState = atom<DailyNetworkStats['threshold']>({\n  key: RECOIL_PREFIX + 'networkThreshold',\n  default: 'good',\n});\n\nexport const DailyNetwork: React.FC<React.PropsWithChildren<{}>> = ({\n  children,\n}) => {\n  const daily = useDaily();\n\n  const topology = useRecoilValue(topologyState);\n\n  const initTopology = useRecoilCallback(\n    ({ set }) =>\n      async () => {\n        if (!daily) return;\n        const topology = await daily.getNetworkTopology();\n        if (!topology || topology?.topology === 'none') return;\n        set(topologyState, topology.topology);\n      },\n    [daily]\n  );\n\n  useDailyEvent('joined-meeting', initTopology);\n  useDailyEvent(\n    'network-connection',\n    useRecoilCallback(\n      ({ set }) =>\n        (ev) => {\n          switch (ev.event) {\n            case 'connected':\n              if (ev.type === 'peer-to-peer') set(topologyState, 'peer');\n              if (ev.type === 'sfu') set(topologyState, 'sfu');\n              break;\n          }\n        },\n      []\n    )\n  );\n  useDailyEvent(\n    'network-quality-change',\n    useRecoilCallback(\n      ({ transact_UNSTABLE }) =>\n        (ev) => {\n          transact_UNSTABLE(({ set }) => {\n            set(networkQualityState, (prevQuality) =>\n              prevQuality !== ev.quality ? ev.quality : prevQuality\n            );\n            set(networkThresholdState, (prevThreshold) =>\n              prevThreshold !== ev.threshold ? ev.threshold : prevThreshold\n            );\n          });\n        },\n      []\n    )\n  );\n\n  useDailyEvent(\n    'left-meeting',\n    useRecoilCallback(\n      ({ transact_UNSTABLE }) =>\n        () => {\n          transact_UNSTABLE(({ reset }) => {\n            reset(topologyState);\n            reset(networkQualityState);\n            reset(networkThresholdState);\n          });\n        },\n      []\n    )\n  );\n\n  useEffect(() => {\n    if (!daily || topology !== 'none') return;\n    initTopology();\n  }, [daily, initTopology, topology]);\n\n  return <>{children}</>;\n};\n","import { DailyStreamingLayoutConfig } from '@daily-co/daily-js';\nimport React, { useEffect } from 'react';\nimport { atom, useRecoilCallback, useSetRecoilState } from 'recoil';\n\nimport { useDailyEvent } from './hooks/useDailyEvent';\nimport { useLocalSessionId } from './hooks/useLocalSessionId';\nimport { useParticipantIds } from './hooks/useParticipantIds';\nimport { RECOIL_PREFIX } from './lib/constants';\n\ninterface RecordingState {\n  /**\n   * Determines whether an error occurred during the last recording attempt.\n   */\n  error?: boolean;\n  /**\n   * Determines whether the local participant is being recorded, based on the recording settings.\n   */\n  isLocalParticipantRecorded: boolean;\n  /**\n   * Determines whether a recording is currently running or not.\n   */\n  isRecording: boolean;\n  /**\n   * Contains the last applied cloud recording layout config.\n   */\n  layout?: DailyStreamingLayoutConfig;\n  /**\n   * Determines whether the recording is running locally.\n   * See [enable_recording](https://docs.daily.co/reference/rest-api/rooms/config#enable_recording).\n   */\n  local?: boolean;\n  /**\n   * Contains the recording id.\n   */\n  recordingId?: string;\n  /**\n   * Contains the date when the 'recording-started' event was received.\n   * This doesn't necessarily match the date the recording was actually started.\n   */\n  recordingStartedDate?: Date;\n  /**\n   * Contains the session_id of the participant who started the recording.\n   */\n  startedBy?: string;\n  /**\n   * Contains the recording type.\n   * See [enable_recording](https://docs.daily.co/reference/rest-api/rooms/config#enable_recording).\n   */\n  type?: string;\n}\n\nexport const recordingState = atom<RecordingState>({\n  key: RECOIL_PREFIX + 'recording',\n  default: {\n    isLocalParticipantRecorded: false,\n    isRecording: false,\n  },\n});\n\nexport const DailyRecordings: React.FC<React.PropsWithChildren<unknown>> = ({\n  children,\n}) => {\n  const setState = useSetRecoilState(recordingState);\n\n  const localSessionId = useLocalSessionId();\n\n  const recordingParticipantIds = useParticipantIds({\n    filter: 'record',\n  });\n  /**\n   * Update recording state, whenever amount of recording participants changes.\n   */\n  useEffect(() => {\n    const hasRecordingParticipants = recordingParticipantIds.length > 0;\n    const isLocalParticipantRecording = recordingParticipantIds.includes(\n      localSessionId || 'local'\n    );\n    setState((s) => ({\n      ...s,\n      // In case type is local or not set, determine based on recording participants\n      isLocalParticipantRecorded:\n        s?.type === 'local' || !s?.type\n          ? hasRecordingParticipants\n          : s.isLocalParticipantRecorded,\n      isRecording:\n        s?.type === 'local' || !s?.type\n          ? hasRecordingParticipants\n          : s.isRecording,\n      local:\n        (s?.type === 'local' || !s?.type) && hasRecordingParticipants\n          ? isLocalParticipantRecording\n          : s?.local,\n      /**\n       * Set type in case recording participants are detected.\n       * We only set `record` on participants, when recording type is 'local'.\n       */\n      type: hasRecordingParticipants ? 'local' : s?.type,\n    }));\n  }, [localSessionId, recordingParticipantIds, setState]);\n\n  useDailyEvent(\n    'recording-started',\n    useRecoilCallback(\n      ({ set }) =>\n        (ev) => {\n          let isLocalParticipantRecorded = true;\n          switch (ev.type) {\n            case 'cloud-beta':\n            case 'cloud': {\n              if (\n                localSessionId &&\n                ev.layout?.preset === 'single-participant' &&\n                ev.layout.session_id !== localSessionId\n              ) {\n                isLocalParticipantRecorded = false;\n              }\n              break;\n            }\n          }\n          set(recordingState, {\n            error: false,\n            isLocalParticipantRecorded,\n            isRecording: true,\n            layout: ev?.layout,\n            local: ev?.local,\n            recordingId: ev?.recordingId,\n            recordingStartedDate: new Date(),\n            startedBy: ev?.startedBy,\n            type: ev?.type,\n          });\n        },\n      [localSessionId]\n    )\n  );\n  useDailyEvent(\n    'recording-stopped',\n    useRecoilCallback(\n      ({ set }) =>\n        () => {\n          set(recordingState, (prevState) => ({\n            ...prevState,\n            isLocalParticipantRecorded: false,\n            isRecording: false,\n          }));\n        },\n      []\n    )\n  );\n  useDailyEvent(\n    'recording-error',\n    useRecoilCallback(\n      ({ set }) =>\n        () => {\n          set(recordingState, (prevState) => ({\n            ...prevState,\n            error: true,\n            isLocalParticipantRecorded: false,\n            isRecording: false,\n          }));\n        },\n      []\n    )\n  );\n  useDailyEvent(\n    'left-meeting',\n    useRecoilCallback(\n      ({ reset }) =>\n        () => {\n          reset(recordingState);\n        },\n      []\n    )\n  );\n  return <>{children}</>;\n};\n","import { DailyMeetingState } from '@daily-co/daily-js';\nimport { useDebugValue } from 'react';\nimport { useRecoilValue } from 'recoil';\n\nimport { meetingStateState } from '../DailyMeeting';\n\n/**\n * Returns a meeting's current state.\n */\nexport const useMeetingState = (): DailyMeetingState | null => {\n  const meetingState = useRecoilValue(meetingStateState);\n  useDebugValue(meetingState);\n  return meetingState;\n};\n","import { DailyRoomInfo } from '@daily-co/daily-js';\nimport React from 'react';\nimport { atom, useRecoilCallback } from 'recoil';\n\nimport { useDaily } from './hooks/useDaily';\nimport { useDailyEvent } from './hooks/useDailyEvent';\nimport { useMeetingState } from './hooks/useMeetingState';\nimport { RECOIL_PREFIX } from './lib/constants';\n\nexport const roomState = atom<DailyRoomInfo | null>({\n  key: RECOIL_PREFIX + 'room',\n  default: null,\n});\n\nexport const DailyRoom: React.FC<React.PropsWithChildren<{}>> = ({\n  children,\n}) => {\n  const daily = useDaily();\n  const meetingState = useMeetingState();\n\n  const updateRoom = useRecoilCallback(\n    ({ set }) =>\n      async () => {\n        if (!daily || meetingState === 'left-meeting') return;\n        const room = await daily.room();\n        if (room && 'id' in room) {\n          set(roomState, room);\n        }\n        return room;\n      },\n    [daily, meetingState]\n  );\n\n  useDailyEvent('access-state-updated', updateRoom);\n\n  useDailyEvent(\n    'left-meeting',\n    useRecoilCallback(\n      ({ reset }) =>\n        () => {\n          reset(roomState);\n        },\n      []\n    )\n  );\n\n  return <>{children}</>;\n};\n","import {\n  DailyEventObjectAppMessage,\n  DailyTranscriptionDeepgramOptions,\n} from '@daily-co/daily-js';\nimport React from 'react';\nimport { atom, useRecoilCallback } from 'recoil';\n\nimport { useDailyEvent } from './hooks/useDailyEvent';\nimport { RECOIL_PREFIX } from './lib/constants';\n\nexport interface Transcription {\n  session_id: string;\n  user_id: string;\n  is_final: boolean;\n  text: string;\n  timestamp: string;\n}\n\ninterface TranscriptionState extends DailyTranscriptionDeepgramOptions {\n  /**\n   * Determines whether an error occurred during the last transcription attempt.\n   */\n  error?: boolean;\n  /**\n   * Determines whether a transcription is currently running or not.\n   */\n  isTranscribing: boolean;\n  /**\n   * Contains the date when the 'transcription-started' event was received.\n   * This doesn't necessarily match the date the transcription was actually started.\n   */\n  transcriptionStartDate?: Date;\n  /**\n   * Contains the session_id of the participant who started the transcription.\n   */\n  startedBy?: string;\n  /**\n   * Contains the session_id of the participant who updated the transcription.\n   */\n  updatedBy?: string;\n  /**\n   * Contains the transcriptions that we received.\n   */\n  transcriptions: Transcription[];\n}\n\nexport const transcriptionState = atom<TranscriptionState>({\n  key: RECOIL_PREFIX + 'transcription',\n  default: {\n    isTranscribing: false,\n    model: 'general',\n    language: 'en',\n    transcriptions: [],\n  },\n});\n\nexport const DailyTranscriptions: React.FC<React.PropsWithChildren<{}>> = ({\n  children,\n}) => {\n  useDailyEvent(\n    'transcription-started',\n    useRecoilCallback(\n      ({ set }) =>\n        (ev) => {\n          set(transcriptionState, {\n            error: false,\n            isTranscribing: true,\n            transcriptionStartDate: new Date(),\n            transcriptions: [],\n            ...ev,\n          });\n        },\n      []\n    )\n  );\n  useDailyEvent(\n    'transcription-stopped',\n    useRecoilCallback(\n      ({ set }) =>\n        (ev) => {\n          set(transcriptionState, (prevState) => ({\n            ...prevState,\n            updatedBy: ev?.updatedBy,\n            isTranscribing: false,\n          }));\n        },\n      []\n    )\n  );\n  useDailyEvent(\n    'transcription-error',\n    useRecoilCallback(\n      ({ set }) =>\n        () => {\n          set(transcriptionState, (prevState) => ({\n            ...prevState,\n            error: true,\n            isTranscribing: false,\n          }));\n        },\n      []\n    )\n  );\n  useDailyEvent(\n    'left-meeting',\n    useRecoilCallback(\n      ({ set }) =>\n        () => {\n          set(transcriptionState, (prevState) => ({\n            ...prevState,\n            isTranscribing: false,\n          }));\n        },\n      []\n    )\n  );\n  useDailyEvent(\n    'app-message',\n    useRecoilCallback(\n      ({ set }) =>\n        (ev: DailyEventObjectAppMessage<Transcription>) => {\n          if (ev?.fromId === 'transcription' && ev?.data?.is_final) {\n            set(transcriptionState, (prevState) => ({\n              ...prevState,\n              // setting it to true whenever a new message is received\n              // as the participants who joined after the transcription-started event\n              // won't be knowing if transcription is started or not\n              isTranscribing: true,\n              transcriptions: [...prevState.transcriptions, ev.data],\n            }));\n          }\n        },\n      []\n    )\n  );\n\n  return <>{children}</>;\n};\n","import Daily, { DailyCall, DailyFactoryOptions } from '@daily-co/daily-js';\nimport { useEffect, useRef, useState } from 'react';\n\nimport { customDeepEqual } from '../lib/customDeepEqual';\n\ntype InstanceType = 'callFrame' | 'callObject';\n\nconst defaultOptions: DailyFactoryOptions = {};\nconst defaultShouldCreateInstance = () => true;\n\nexport interface Props {\n  parentEl?: HTMLElement | null;\n  options?: DailyFactoryOptions;\n  shouldCreateInstance?(): boolean;\n}\n\nconst defaultProps: Props = {\n  options: defaultOptions,\n  shouldCreateInstance: defaultShouldCreateInstance,\n};\n\n/**\n * Helper hook to maintain custom call instances in React codebases.\n */\nexport const useCallInstance = (\n  type: InstanceType,\n  {\n    parentEl,\n    options = defaultOptions,\n    shouldCreateInstance = defaultShouldCreateInstance,\n  }: Props = defaultProps\n) => {\n  const [callInstance, setCallInstance] = useState<DailyCall | null>(null);\n\n  /**\n   * Holds last used props when callObject instance was created.\n   */\n  const lastUsedOptions = useRef<DailyFactoryOptions>();\n  useEffect(() => {\n    /**\n     * Call frame instances with a defined parentEl likely pass a ref.\n     * Typically a DOM ref is initialized with useRef(null).\n     * We'll want to wait until parentEl is defined, meaning that the ref is\n     * correctly wired up with a DOM element.\n     * Otherwise we'll just check shouldCreateInstance().\n     */\n    if ((type === 'callFrame' && parentEl === null) || !shouldCreateInstance())\n      return;\n\n    async function destroyCallInstance(co: DailyCall) {\n      await co.destroy();\n    }\n\n    /**\n     * Once instance is destroyed, nullify callInstance, so a new one can be created.\n     */\n    const handleDestroyedInstance = () => {\n      /**\n       * Setting a timeout makes sure the destruction and creation\n       * of call instances happen in separate call stacks.\n       * Otherwise there's a risk for duplicate call instances.\n       */\n      setTimeout(() => setCallInstance(null), 0);\n    };\n\n    let co = Daily.getCallInstance();\n\n    /**\n     * In case a call instance exists outside of this hook instance's knowledge,\n     * store it in state.\n     */\n    if (!callInstance && co && !co.isDestroyed()) {\n      co.once('call-instance-destroyed', handleDestroyedInstance);\n      setCallInstance(co);\n      return;\n    }\n\n    /**\n     * callInstance exists.\n     */\n    if (callInstance) {\n      /**\n       * Props have changed. Destroy current instance, so a new one can be created.\n       */\n      if (!customDeepEqual(lastUsedOptions.current, options)) {\n        destroyCallInstance(callInstance);\n      }\n      /**\n       * Return early.\n       */\n      return;\n    }\n\n    if (!co || co.isDestroyed()) {\n      /**\n       * callInstance doesn't exist or is destroyed (TODO: Check why getCallInstance() can return a destroyed instance),\n       * but should be created.\n       * Important to spread props, because createCallObject/createFrame alters the passed object (adds layout and dailyJsVersion).\n       */\n      switch (type) {\n        case 'callFrame':\n          co = parentEl\n            ? Daily.createFrame(parentEl, { ...options })\n            : Daily.createFrame({ ...options });\n          break;\n        case 'callObject':\n          co = Daily.createCallObject({ ...options });\n          break;\n      }\n      lastUsedOptions.current = options;\n    }\n\n    setCallInstance(co);\n\n    co.once('call-instance-destroyed', handleDestroyedInstance);\n\n    /**\n     * No cleanup phase here, because callObject.destroy() returns a Promise.\n     * We can't have asynchronous cleanups in a useEffect.\n     * To avoid infinite render loops we compare the props when creating call object instances.\n     */\n  }, [callInstance, options, parentEl, shouldCreateInstance, type]);\n\n  return callInstance;\n};\n","import { Props, useCallInstance } from './useCallInstance';\n\ntype CallObjectProps = Omit<Props, 'parentEl'>;\n\n/**\n * Helper hook to maintain custom callObject instances in React codebases.\n */\nexport const useCallObject = (props: CallObjectProps) =>\n  useCallInstance('callObject', props);\n","import { DailyEventObject } from '@daily-co/daily-js';\nimport { useCallback, useDebugValue } from 'react';\nimport { useRecoilValue } from 'recoil';\n\nimport { participantState } from '../DailyParticipants';\nimport { useThrottledDailyEvent } from './useThrottledDailyEvent';\n\ninterface UseParticipantArgs {\n  onParticipantLeft?(ev: DailyEventObject<'participant-left'>): void;\n  onParticipantUpdated?(ev: DailyEventObject<'participant-updated'>): void;\n}\n\n/**\n * Returns the participant identified by the given sessionId.\n * @param sessionId  The participant's session_id or \"local\".\n * @deprecated Use [useParticipantProperty](https://docs.daily.co/reference/daily-react/use-participant-property) instead to only subscribe to required participant properties.\n */\nexport const useParticipant = (\n  sessionId: string,\n  { onParticipantLeft, onParticipantUpdated }: UseParticipantArgs = {}\n) => {\n  const participant = useRecoilValue(participantState(sessionId));\n\n  useThrottledDailyEvent(\n    ['participant-updated', 'participant-left'],\n    useCallback(\n      (evts) => {\n        const filteredEvts = evts.filter(\n          (ev) => ev.participant.session_id === sessionId\n        );\n        if (!filteredEvts.length) return;\n        filteredEvts.forEach((ev) => {\n          switch (ev.action) {\n            case 'participant-updated':\n              onParticipantUpdated?.(ev);\n              break;\n            case 'participant-left':\n              onParticipantLeft?.(ev);\n              break;\n          }\n        });\n      },\n      [onParticipantLeft, onParticipantUpdated, sessionId]\n    )\n  );\n\n  useDebugValue(participant);\n\n  return participant;\n};\n","const audioLevelProcessor = `\n    class AudioLevelProcessor extends AudioWorkletProcessor {\n    volume;\n    interval;\n    nextFrame;\n    \n    constructor() {\n      super();\n      this.volume = 0;\n      this.interval = 25;\n      this.nextFrame = this.interval;\n    }\n    \n    get intervalInFrames() {\n      // sampleRate is globally defined in AudioWorklets.\n      // See https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletGlobalScope\n      // eslint-disable-next-line no-undef\n      return (this.interval / 1000) * sampleRate;\n    }\n    \n    process(inputList) {\n      const firstInput = inputList[0];\n    \n      if (firstInput.length > 0) {\n        const inputData = firstInput[0];\n        let total = 0;\n    \n        for (let i = 0; i < inputData.length; ++i) {\n          total += Math.abs(inputData[i]);\n        }\n    \n        const rms = Math.sqrt(total / inputData.length);\n        this.volume = Math.max(0, Math.min(1, rms));\n    \n        this.nextFrame -= inputData.length;\n        if (this.nextFrame < 0) {\n          this.nextFrame += this.intervalInFrames;\n          this.port.postMessage({ volume: this.volume });\n        }\n      }\n    \n      return true;\n    }\n    }\n    \n    registerProcessor('audiolevel', AudioLevelProcessor);              \n`;\n\nexport const inlineAudioWorklet = `data:application/javascript;charset=utf8,${encodeURIComponent(\n  audioLevelProcessor\n)}`;\n","import { DailyCpuLoadStats, DailyEventObject } from '@daily-co/daily-js';\nimport deepEqual from 'fast-deep-equal';\nimport { useCallback, useDebugValue, useEffect } from 'react';\nimport { atom, useRecoilCallback, useRecoilValue } from 'recoil';\n\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\nimport { useMeetingState } from './useMeetingState';\n\ninterface CPULoad {\n  state: DailyCpuLoadStats['cpuLoadState'];\n  reason: DailyCpuLoadStats['cpuLoadStateReason'];\n}\n\nconst CPULoadState = atom<CPULoad>({\n  key: 'cpu-load-state',\n  default: {\n    state: 'low',\n    reason: 'none',\n  },\n});\n\ninterface Props {\n  onCPULoadChange?(ev: DailyEventObject<'cpu-load-change'>): void;\n}\n\n/**\n * Returns the current CPU load as reported by daily-js [cpu-load-change](https://docs.daily.co/reference/daily-js/events/quality-events#cpu-load-change) events\n * and [getCpuLoadStats](https://docs.daily.co/reference/daily-js/instance-methods/get-cpu-load-stats).\n */\nexport const useCPULoad = ({ onCPULoadChange }: Props = {}) => {\n  const cpu = useRecoilValue(CPULoadState);\n  const daily = useDaily();\n  const meetingState = useMeetingState();\n\n  const updateCPULoadState = useRecoilCallback(\n    ({ set, snapshot }) =>\n      async (cpu: CPULoad) => {\n        const prev = await snapshot.getPromise(CPULoadState);\n        if (deepEqual(prev, cpu)) return;\n        set(CPULoadState, cpu);\n      },\n    []\n  );\n\n  useEffect(() => {\n    let mounted = true;\n    if (!daily || daily.isDestroyed() || meetingState !== 'joined-meeting')\n      return;\n    daily.getCpuLoadStats().then((stats) => {\n      if (!mounted) return;\n      updateCPULoadState({\n        state: stats.cpuLoadState,\n        reason: stats.cpuLoadStateReason,\n      });\n    });\n    return () => {\n      mounted = false;\n    };\n  }, [daily, meetingState, updateCPULoadState]);\n\n  useDailyEvent(\n    'cpu-load-change',\n    useCallback(\n      (ev) => {\n        updateCPULoadState({\n          state: ev.cpuLoadState,\n          reason: ev.cpuLoadStateReason,\n        });\n        onCPULoadChange?.(ev);\n      },\n      [onCPULoadChange, updateCPULoadState]\n    )\n  );\n\n  useDebugValue(cpu);\n\n  return cpu;\n};\n","import { useDebugValue } from 'react';\nimport { useRecoilValue } from 'recoil';\n\nimport { meetingErrorState, nonFatalErrorState } from '../DailyMeeting';\n\n/**\n * Returns a meeting's last known errors.\n */\nexport const useDailyError = () => {\n  const meetingError = useRecoilValue(meetingErrorState);\n  const nonFatalError = useRecoilValue(nonFatalErrorState);\n  const result = {\n    meetingError,\n    nonFatalError,\n  };\n  useDebugValue(result);\n  return result;\n};\n","import {\n  DailyCall,\n  DailyEventObject,\n  DailyEventObjectNonFatalError,\n  DailyInputSettings,\n} from '@daily-co/daily-js';\nimport { useCallback, useDebugValue, useEffect } from 'react';\nimport { atom, useRecoilCallback, useRecoilValue } from 'recoil';\n\nimport { RECOIL_PREFIX } from '../lib/constants';\nimport { Reconstruct } from '../types/Reconstruct';\nimport { useDaily } from './useDaily';\nimport { useDailyError } from './useDailyError';\nimport { useDailyEvent } from './useDailyEvent';\n\ntype DailyEventObjectInputSettingsError = Reconstruct<\n  DailyEventObjectNonFatalError,\n  'type',\n  'input-settings-error'\n>;\n\ninterface UseInputSettingsArgs {\n  onError?(ev: DailyEventObjectInputSettingsError): void;\n  onInputSettingsUpdated?(ev: DailyEventObject<'input-settings-updated'>): void;\n}\n\nconst inputSettingsState = atom<DailyInputSettings | null>({\n  key: RECOIL_PREFIX + 'input-settings',\n  default: null,\n});\n\nexport const useInputSettings = ({\n  onError,\n  onInputSettingsUpdated,\n}: UseInputSettingsArgs = {}) => {\n  const inputSettings = useRecoilValue(inputSettingsState);\n  const { nonFatalError } = useDailyError();\n  const daily = useDaily();\n\n  const updateInputSettingsState = useRecoilCallback(\n    ({ set }) =>\n      (inputSettings: DailyInputSettings) => {\n        set(inputSettingsState, inputSettings);\n      },\n    []\n  );\n\n  useEffect(() => {\n    if (!daily) return;\n    daily.getInputSettings().then(updateInputSettingsState);\n  }, [daily, updateInputSettingsState]);\n\n  /**\n   * Handle 'input-settings-updated' events.\n   */\n  useDailyEvent(\n    'input-settings-updated',\n    useCallback(\n      (ev) => {\n        updateInputSettingsState(ev.inputSettings);\n        onInputSettingsUpdated?.(ev);\n      },\n      [onInputSettingsUpdated, updateInputSettingsState]\n    )\n  );\n\n  /**\n   * Handle nonfatal errors of type 'input-settings-error'.\n   */\n  useDailyEvent(\n    'nonfatal-error',\n    useCallback(\n      (ev) => {\n        if (ev.type !== 'input-settings-error') return;\n        onError?.(ev as DailyEventObjectInputSettingsError);\n      },\n      [onError]\n    )\n  );\n\n  /**\n   * Calls daily.updateInputSettings internally.\n   */\n  const updateInputSettings = useCallback(\n    (...args: Parameters<DailyCall['updateInputSettings']>) => {\n      return daily?.updateInputSettings(...args);\n    },\n    [daily]\n  );\n\n  const result = {\n    errorMsg:\n      nonFatalError?.type === 'input-settings-error'\n        ? nonFatalError.errorMsg\n        : null,\n    inputSettings,\n    updateInputSettings,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import { DailyEventObject, DailyParticipantCounts } from '@daily-co/daily-js';\nimport { useCallback, useDebugValue, useEffect } from 'react';\nimport { atom, useRecoilCallback, useRecoilValue } from 'recoil';\n\nimport { RECOIL_PREFIX } from '../lib/constants';\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\n\nconst participantCountsState = atom<DailyParticipantCounts>({\n  key: RECOIL_PREFIX + 'participant-counts',\n  default: {\n    hidden: 0,\n    present: 0,\n  },\n});\n\ninterface Props {\n  onParticipantCountsUpdated?(\n    ev: DailyEventObject<'participant-counts-updated'>\n  ): void;\n}\n\n/**\n * Returns participant counts for hidden and present participants.\n */\nexport const useParticipantCounts = ({\n  onParticipantCountsUpdated,\n}: Props = {}) => {\n  const daily = useDaily();\n  const participantCounts = useRecoilValue(participantCountsState);\n\n  const updateCounts = useRecoilCallback(\n    ({ set }) =>\n      (counts: DailyParticipantCounts) => {\n        set(participantCountsState, counts);\n      },\n    []\n  );\n\n  useDailyEvent(\n    'participant-counts-updated',\n    useCallback(\n      (ev) => {\n        updateCounts(ev.participantCounts);\n        onParticipantCountsUpdated?.(ev);\n      },\n      [onParticipantCountsUpdated, updateCounts]\n    )\n  );\n\n  useEffect(() => {\n    if (!daily || daily.isDestroyed()) return;\n    updateCounts(daily.participantCounts());\n  }, [daily, updateCounts]);\n\n  useDebugValue(participantCounts);\n\n  return participantCounts;\n};\n","import {\n  DailyCall,\n  DailyEventObject,\n  DailyReceiveSettings,\n  DailySingleParticipantReceiveSettings,\n} from '@daily-co/daily-js';\nimport { useCallback, useDebugValue, useEffect } from 'react';\nimport { atomFamily, useRecoilCallback, useRecoilValue } from 'recoil';\n\nimport { RECOIL_PREFIX } from '../lib/constants';\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\nimport { useMeetingState } from './useMeetingState';\n\nconst participantReceiveSettingsState = atomFamily<\n  DailySingleParticipantReceiveSettings,\n  string\n>({\n  key: RECOIL_PREFIX + 'participant-receive-settings',\n  default: {},\n});\n\ninterface UseReceiveSettingsArgs {\n  id?: string;\n  onReceiveSettingsUpdated?(\n    ev: DailyEventObject<'receive-settings-updated'>\n  ): void;\n}\n\n/**\n * Allows to read and set receiveSettings.\n * In case receiveSettings for participant specified by id are empty, not set or 'inherit',\n * base receiveSettings will be returned.\n * In case meeting is not in joined state, calls to updateReceiveSettings will be silently ignored.\n */\nexport const useReceiveSettings = ({\n  id = 'base',\n  onReceiveSettingsUpdated,\n}: UseReceiveSettingsArgs = {}) => {\n  const baseSettings = useRecoilValue(participantReceiveSettingsState('base'));\n  const receiveSettings = useRecoilValue(participantReceiveSettingsState(id));\n  const daily = useDaily();\n  const meetingState = useMeetingState();\n\n  const updateReceiveSettingsState = useRecoilCallback(\n    ({ transact_UNSTABLE }) =>\n      (receiveSettings: DailyReceiveSettings) => {\n        transact_UNSTABLE(({ reset, set }) => {\n          const { ...ids } = receiveSettings;\n          for (let [id, settings] of Object.entries(ids)) {\n            set(participantReceiveSettingsState(id), settings);\n          }\n          if (!(id in ids)) {\n            reset(participantReceiveSettingsState(id));\n          }\n        });\n      },\n    [id]\n  );\n  useDailyEvent(\n    'receive-settings-updated',\n    useCallback(\n      (ev) => {\n        updateReceiveSettingsState(ev.receiveSettings);\n        onReceiveSettingsUpdated?.(ev);\n      },\n      [onReceiveSettingsUpdated, updateReceiveSettingsState]\n    )\n  );\n\n  useEffect(() => {\n    if (!daily || daily.isDestroyed()) return;\n    daily.getReceiveSettings().then(updateReceiveSettingsState);\n  }, [daily, updateReceiveSettingsState]);\n\n  const updateReceiveSettings = useCallback(\n    (...args: Parameters<DailyCall['updateReceiveSettings']>) => {\n      if (!daily || meetingState !== 'joined-meeting') return;\n      daily?.updateReceiveSettings?.(...args);\n    },\n    [daily, meetingState]\n  );\n\n  const result = {\n    receiveSettings:\n      id === 'base' || Object.keys(receiveSettings).length === 0\n        ? baseSettings\n        : receiveSettings,\n    updateReceiveSettings,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import { DailyRoomInfo } from '@daily-co/daily-js';\nimport { useDebugValue } from 'react';\nimport { useRecoilValue } from 'recoil';\n\nimport { roomState } from '../DailyRoom';\n\n/**\n * Stateful hook to work with room, domain and token configuration for a daily room.\n * Includes room default values.\n */\nexport const useRoom = (): DailyRoomInfo | null => {\n  const room = useRecoilValue(roomState);\n  useDebugValue(room);\n  return room;\n};\n","import {\n  DailyCall,\n  DailyEventObject,\n  DailySendSettings,\n} from '@daily-co/daily-js';\nimport { useCallback, useDebugValue, useEffect } from 'react';\nimport { atom, useRecoilCallback, useRecoilValue } from 'recoil';\n\nimport { RECOIL_PREFIX } from '../lib/constants';\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\n\nconst sendSettingsState = atom<DailySendSettings | null>({\n  key: RECOIL_PREFIX + 'send-settings',\n  default: null,\n});\n\ninterface Props {\n  onSendSettingsUpdated?(ev: DailyEventObject<'send-settings-updated'>): void;\n}\n\n/**\n * Returns the current media send settings and an updater function to change the settings.\n */\nexport const useSendSettings = ({ onSendSettingsUpdated }: Props = {}) => {\n  const daily = useDaily();\n  const sendSettings = useRecoilValue(sendSettingsState);\n\n  useDailyEvent(\n    'send-settings-updated',\n    useRecoilCallback(\n      ({ set }) =>\n        (ev) => {\n          set(sendSettingsState, ev.sendSettings);\n          onSendSettingsUpdated?.(ev);\n        },\n      [onSendSettingsUpdated]\n    )\n  );\n\n  const storeSendSettings = useRecoilCallback(\n    ({ set }) =>\n      (sendSettings: DailySendSettings | null) => {\n        set(sendSettingsState, sendSettings);\n      },\n    []\n  );\n\n  useEffect(() => {\n    if (!daily || daily.isDestroyed()) return;\n    storeSendSettings(daily.getSendSettings());\n  }, [daily, storeSendSettings]);\n\n  /**\n   * Updates the local clients send settings.\n   * See https://docs.daily.co/reference/daily-js/instance-methods/update-send-settings for details.\n   */\n  const updateSendSettings = useCallback(\n    async (...args: Parameters<DailyCall['updateSendSettings']>) => {\n      const newSendSettings = await daily?.updateSendSettings(...args);\n      if (!newSendSettings) return;\n      storeSendSettings(newSendSettings);\n      return newSendSettings;\n    },\n    [daily, storeSendSettings]\n  );\n\n  const result = {\n    sendSettings,\n    updateSendSettings,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import {\n  DailyCall,\n  DailyEvent,\n  DailyEventObject,\n  DailyFactoryOptions,\n} from '@daily-co/daily-js';\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react';\nimport { RecoilRoot, RecoilRootProps } from 'recoil';\n\nimport { DailyContext } from './DailyContext';\nimport { DailyDevices } from './DailyDevices';\nimport { DailyEventContext } from './DailyEventContext';\nimport { DailyLiveStreaming } from './DailyLiveStreaming';\nimport { DailyMeeting } from './DailyMeeting';\nimport { DailyNetwork } from './DailyNetwork';\nimport { DailyParticipants } from './DailyParticipants';\nimport { DailyRecordings } from './DailyRecordings';\nimport { DailyRoom } from './DailyRoom';\nimport { DailyTranscriptions } from './DailyTranscriptions';\nimport { useCallObject } from './hooks/useCallObject';\n\ntype BaseProps =\n  | DailyFactoryOptions\n  | {\n      callObject: DailyCall | null;\n    };\n\ntype Props = BaseProps & {\n  /**\n   * Allows to override props for [RecoilRoot](https://recoiljs.org/docs/api-reference/core/RecoilRoot/).\n   * In case you use Recoil in your own application, you can pass `override: false` to allow\n   * daily-react to store its state in your application's RecoilRoot.\n   * Default value: {}\n   */\n  recoilRootProps?: Omit<RecoilRootProps, 'children'>;\n};\n\ntype EventsMap = Partial<Record<DailyEvent, Map<number, Function>>>;\n\nexport const DailyProvider: React.FC<React.PropsWithChildren<Props>> = ({\n  children,\n  recoilRootProps = {},\n  ...props\n}) => {\n  const eventsMap = useRef<EventsMap>({});\n\n  /**\n   * Generic event handler to loop through registered event callbacks.\n   */\n  const handleEvent = useCallback((ev: DailyEventObject) => {\n    if (!('action' in ev)) return;\n    const event = ev.action as DailyEvent;\n    for (let cb of eventsMap.current?.[event]?.values() ?? []) {\n      cb(ev);\n    }\n  }, []);\n\n  /**\n   * In case events are set up via useDailyEvent before a DailyCall instance is available,\n   * we'll register the events whenever daily is set.\n   */\n  const initEventHandlers = useCallback(\n    (daily: DailyCall) => {\n      if (!daily) return;\n      (Object.keys(eventsMap.current) as DailyEvent[]).forEach((event) => {\n        daily.off(event as DailyEvent, handleEvent);\n        if (!daily.isDestroyed()) {\n          daily.on(event as DailyEvent, handleEvent);\n        }\n      });\n    },\n    [handleEvent]\n  );\n\n  const externalCallObject = 'callObject' in props ? props.callObject : null;\n\n  const memoizedOptions = useMemo(\n    () => ('callObject' in props ? {} : props),\n    [props]\n  );\n  const internalCallObject = useCallObject({\n    options: memoizedOptions,\n    shouldCreateInstance: useCallback(() => {\n      return !('callObject' in props);\n    }, [props]),\n  });\n\n  const callObject = externalCallObject ?? internalCallObject;\n\n  useEffect(() => {\n    if (!callObject) return;\n    initEventHandlers(callObject);\n  }, [callObject, initEventHandlers]);\n\n  /**\n   * Registers event callback.\n   */\n  const on = useCallback(\n    (ev: DailyEvent, cb: Function, key: number) => {\n      if (!eventsMap.current[ev]) {\n        eventsMap.current[ev] = new Map();\n        if (callObject) {\n          /**\n           * Make sure only 1 event listener is registered at anytime for handleEvent.\n           * Otherwise, events sent from daily-js might be handled multiple times.\n           */\n          callObject.off(ev, handleEvent);\n          if (!callObject.isDestroyed()) {\n            callObject.on(ev, handleEvent);\n          }\n        }\n      }\n      if (!eventsMap.current[ev]?.has(key)) {\n        eventsMap.current[ev]?.set(key, cb);\n      }\n    },\n    [callObject, handleEvent]\n  );\n\n  /**\n   * Unregisters event callback.\n   */\n  const off = useCallback(\n    (ev: DailyEvent, key: number) => {\n      eventsMap.current[ev]?.delete(key);\n      if (eventsMap.current[ev]?.size === 0) {\n        callObject?.off(ev, handleEvent);\n        delete eventsMap.current[ev];\n      }\n    },\n    [callObject, handleEvent]\n  );\n\n  return (\n    <RecoilRoot {...recoilRootProps}>\n      <DailyContext.Provider value={callObject}>\n        <DailyEventContext.Provider value={{ on, off }}>\n          <DailyRoom>\n            <DailyMeeting>\n              <DailyNetwork>\n                <DailyParticipants>\n                  <DailyRecordings>\n                    <DailyLiveStreaming>\n                      <DailyTranscriptions>\n                        <DailyDevices>{children}</DailyDevices>\n                      </DailyTranscriptions>\n                    </DailyLiveStreaming>\n                  </DailyRecordings>\n                </DailyParticipants>\n              </DailyNetwork>\n            </DailyMeeting>\n          </DailyRoom>\n        </DailyEventContext.Provider>\n      </DailyContext.Provider>\n    </RecoilRoot>\n  );\n};\n","import { DailyEventObject } from '@daily-co/daily-js';\nimport { useCallback, useDebugValue, useEffect, useState } from 'react';\nimport { useRecoilValue } from 'recoil';\n\nimport { activeIdState } from '../DailyParticipants';\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\nimport { useParticipant } from './useParticipant';\n\ninterface UseActiveParticipantArgs {\n  /**\n   * If set to true, useActiveParticipant will never return the local participant.\n   */\n  ignoreLocal?: boolean;\n  /**\n   * Optional event callback for [active-speaker-change](https://docs.daily.co/reference/daily-js/events/meeting-events#active-speaker-change) event listener.\n   */\n  onActiveSpeakerChange?(ev: DailyEventObject<'active-speaker-change'>): void;\n}\n\n/**\n * Returns the most recent participant mentioned in an [active-speaker-change](https://docs.daily.co/reference/daily-js/events/meeting-events#active-speaker-change) event.\n * @deprecated Use [useActiveSpeakerId](https://docs.daily.co/reference/daily-react/use-active-speaker-id) instead.\n */\nexport const useActiveParticipant = ({\n  ignoreLocal = false,\n  onActiveSpeakerChange,\n}: UseActiveParticipantArgs = {}) => {\n  const daily = useDaily();\n  const recentActiveId = useRecoilValue(activeIdState);\n  const [activeId, setActiveId] = useState('');\n  const activeParticipant = useParticipant(activeId);\n\n  useEffect(() => {\n    if (!daily) return;\n    const local = daily?.participants()?.local;\n    if (ignoreLocal && recentActiveId === local?.session_id) return;\n\n    // setting activeId as string to avoid passing null to useParticipant hook\n    setActiveId(recentActiveId ?? '');\n  }, [daily, ignoreLocal, recentActiveId]);\n\n  useDailyEvent(\n    'active-speaker-change',\n    useCallback(\n      (ev) => {\n        onActiveSpeakerChange?.(ev);\n      },\n      [onActiveSpeakerChange]\n    )\n  );\n\n  useDebugValue(activeParticipant);\n\n  return activeParticipant;\n};\n","import { DailyEventObjectAppMessage } from '@daily-co/daily-js';\nimport { useCallback } from 'react';\n\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\n\ntype SendAppMessage<Data = any> = (data: Data, to?: string) => void;\n\ninterface UseAppMessageArgs<Data> {\n  /**\n   * Optional event callback for [app-message](https://docs.daily.co/reference/daily-js/events/participant-events#app-message) event listener.\n   * Receives this hook's sendAppMessage as an additional argument to avoid circular dependencies.\n   */\n  onAppMessage?(\n    ev: DailyEventObjectAppMessage<Data>,\n    sendAppMessage?: SendAppMessage<Data>\n  ): void;\n}\n\n/**\n * React hook to setup [app-message](https://docs.daily.co/reference/daily-js/events/participant-events#app-message) listeners and\n * to send messages via [sendAppMessage](https://docs.daily.co/reference/daily-js/instance-methods/send-app-message).\n */\nexport const useAppMessage = <Data = any>({\n  onAppMessage,\n}: UseAppMessageArgs<Data> = {}) => {\n  const daily = useDaily();\n\n  const sendAppMessage: SendAppMessage<Data> = useCallback(\n    (data, to = '*') => {\n      if (!daily) return;\n      daily.sendAppMessage(data, to);\n    },\n    [daily]\n  );\n\n  const handleAppMessage = useCallback(\n    (ev: DailyEventObjectAppMessage<Data>) => {\n      onAppMessage?.(ev, sendAppMessage);\n    },\n    [onAppMessage, sendAppMessage]\n  );\n\n  useDailyEvent('app-message', handleAppMessage);\n\n  return sendAppMessage;\n};\n","import { useEffect, useRef } from 'react';\n\nimport { inlineAudioWorklet } from '../lib/inlineAudioWorklet';\n/**\n * Returns the volume level of a given MediaStreamTrack.\n * @param mediaTrack The MediaStreamTrack to be analysed.\n * @param onVolumeChange The function to execute when the volume changes. Can be used to visualise audio output.\n */\nexport const useAudioLevel = (\n  mediaTrack: MediaStreamTrack | undefined,\n  onVolumeChange: (volume: number) => void\n) => {\n  const audioCtx = useRef<AudioContext>();\n\n  useEffect(\n    function setupStreamAndStartProcessing() {\n      // No mediaTrack. Stop immediately.\n      if (!mediaTrack) return;\n      const AudioCtx =\n        typeof AudioContext !== 'undefined'\n          ? AudioContext\n          : typeof window.webkitAudioContext !== 'undefined'\n          ? window.webkitAudioContext\n          : null;\n      // No AudioContext available in browser. Can't measure audio volume.\n      if (!AudioCtx) return;\n      if (!audioCtx.current) {\n        // No audio context initialized. Initializing now.\n        audioCtx.current = new AudioCtx();\n      }\n      const audioContext = audioCtx.current;\n      // Audio context could not be initialized. Stopping.\n      if (!audioContext) return;\n\n      const mediaStreamSource = audioContext.createMediaStreamSource(\n        new MediaStream([mediaTrack])\n      );\n      let node: AudioWorkletNode | null;\n      let gainNode: GainNode;\n\n      const startProcessing = async () => {\n        /**\n         * Try to add the module only once.\n         * In case it's not added to the audio context, yet, trying to initialize it will fail.\n         * There's only one real reason for `new AudioWorkletNode` to fail and that is\n         * when the corresponding module isn't added to the audio context, yet.\n         * This makes sure we only add the module once.\n         *\n         * We're inlining the worklet instead of loading it via a URL as not to complicate bundling\n         * this package.\n         */\n        try {\n          node = new AudioWorkletNode(audioContext, 'audiolevel');\n          gainNode = audioContext.createGain();\n        } catch {\n          try {\n            await audioContext.audioWorklet.addModule(inlineAudioWorklet);\n            node = new AudioWorkletNode(audioContext, 'audiolevel');\n            gainNode = audioContext.createGain();\n          } catch (e) {\n            console.error(e);\n          }\n        }\n\n        if (!(node && gainNode)) return;\n\n        node.port.onmessage = (event) => {\n          let volume = 0;\n          if (event.data.volume) volume = event.data.volume;\n          if (!node) return;\n          onVolumeChange(volume);\n        };\n\n        gainNode.gain.value = 0;\n\n        try {\n          mediaStreamSource\n            .connect(node)\n            .connect(gainNode)\n            .connect(audioContext.destination);\n        } catch (e) {\n          console.warn(e);\n        }\n      };\n\n      startProcessing();\n\n      return () => {\n        node?.disconnect();\n        node = null;\n        mediaStreamSource?.disconnect();\n      };\n    },\n    [onVolumeChange, mediaTrack]\n  );\n};\n","import { MediaTrackState, useMediaTrack } from './useMediaTrack';\n\n/**\n * Returns a participant's audio track and state.\n * @param participantId The participant's session_id.\n */\nexport const useAudioTrack = (participantId: string): MediaTrackState =>\n  useMediaTrack(participantId, 'audio');\n","import { useCallInstance } from './useCallInstance';\n\ntype Props = Parameters<typeof useCallInstance>[1];\n\n/**\n * Helper hook to maintain custom callFrame instances in React codebases.\n */\nexport const useCallFrame = (props: Props) =>\n  useCallInstance('callFrame', props);\n","import { useCallback, useContext, useDebugValue } from 'react';\nimport { useRecoilValue } from 'recoil';\n\nimport {\n  cameraDevicesState,\n  generalCameraState,\n  generalMicrophoneState,\n  lastCameraErrorState,\n  microphoneDevicesState,\n  speakerDevicesState,\n} from '../DailyDevices';\nimport { DailyDevicesContext } from '../DailyDevicesContext';\nimport { useDaily } from './useDaily';\n\n/**\n * This hook allows access to information about the user's devices and their state.\n */\nexport const useDevices = () => {\n  const daily = useDaily();\n\n  const camState = useRecoilValue(generalCameraState);\n  const micState = useRecoilValue(generalMicrophoneState);\n  const camDevices = useRecoilValue(cameraDevicesState);\n  const micDevices = useRecoilValue(microphoneDevicesState);\n  const speakerDevices = useRecoilValue(speakerDevicesState);\n  const cameraError = useRecoilValue(lastCameraErrorState);\n\n  const { refreshDevices } = useContext(DailyDevicesContext);\n\n  /**\n   * Sets video input device to given deviceId.\n   */\n  const setCamera = useCallback(\n    async (deviceId: string) => {\n      await daily?.setInputDevicesAsync({\n        audioDeviceId: null,\n        videoDeviceId: deviceId,\n      });\n    },\n    [daily]\n  );\n\n  /**\n   * Sets audio input device to given deviceId.\n   */\n  const setMicrophone = useCallback(\n    async (deviceId: string) => {\n      await daily?.setInputDevicesAsync({\n        audioDeviceId: deviceId,\n        videoDeviceId: null,\n      });\n    },\n    [daily]\n  );\n\n  /**\n   * Sets audio output device to given deviceId.\n   */\n  const setSpeaker = useCallback(\n    async (deviceId: string) => {\n      await daily?.setOutputDeviceAsync({\n        outputDeviceId: deviceId,\n      });\n    },\n    [daily]\n  );\n\n  const errorStates: typeof camState[] = [\n    'blocked',\n    'in-use',\n    'not-found',\n    'constraints-invalid',\n    'constraints-none-specified',\n    'undefined-mediadevices',\n    'unknown',\n  ];\n\n  const result = {\n    /**\n     * Most recent error object emitted via [camera-error event](https://docs.daily.co/reference/daily-js/events/meeting-events#camera-error).\n     */\n    cameraError,\n    /**\n     * A list of the user's camera (videoinput) devices. See [MediaDeviceInfo](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo) for more info.\n     */\n    cameras: camDevices,\n    /**\n     * The general state for camera access.\n     */\n    camState,\n    /**\n     * Holds the currently selected camera.\n     */\n    currentCam: camDevices.find((cam) => cam.selected),\n    /**\n     * Holds the currently selected microphone.\n     */\n    currentMic: micDevices.find((mic) => mic.selected),\n    /**\n     * Holds the currently selected speaker.\n     */\n    currentSpeaker: speakerDevices.find((speaker) => speaker.selected),\n    /**\n     * Indicates that there's an issue with camera devices.\n     */\n    hasCamError: errorStates.includes(camState),\n    /**\n     * Indicates that there's an issue with microphone devices.\n     */\n    hasMicError: errorStates.includes(micState),\n    /**\n     * A list of the user's microphone (audioinput) devices. See [MediaDeviceInfo](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo) for more info.\n     */\n    microphones: micDevices,\n    /**\n     * The general state for microphone access.\n     */\n    micState,\n    /**\n     * Refreshes the list of devices using [enumerateDevices](https://docs.daily.co/reference/daily-js/instance-methods/enumerate-devices).\n     */\n    refreshDevices,\n    /**\n     * Allows to switch to the camera with the specified deviceId. Calls [setInputDevicesAsync](https://docs.daily.co/reference/daily-js/instance-methods/set-input-devices-async) internally.\n     */\n    setCamera,\n    /**\n     * Allows to switch to the microphone with the specified deviceId. Calls [setInputDevicesAsync](https://docs.daily.co/reference/daily-js/instance-methods/set-input-devices-async) internally.\n     */\n    setMicrophone,\n    /**\n     * Allows to switch to the speaker with the specified deviceId. Calls [setOutputDevice](https://docs.daily.co/reference/daily-js/instance-methods/set-output-device) internally.\n     */\n    setSpeaker,\n    /**\n     * A list of the user's speaker (audiooutput) devices. See [MediaDeviceInfo](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo) for more info.\n     */\n    speakers: speakerDevices,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import {\n  DailyCall,\n  DailyEventObject,\n  DailyEventObjectNonFatalError,\n} from '@daily-co/daily-js';\nimport { useCallback, useDebugValue } from 'react';\nimport { useRecoilValue } from 'recoil';\n\nimport { liveStreamingState } from '../DailyLiveStreaming';\nimport { Reconstruct } from '../types/Reconstruct';\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\n\ntype DailyEventObjectLiveStreamingWarning = Reconstruct<\n  DailyEventObjectNonFatalError,\n  'type',\n  'live-streaming-warning'\n>;\n\ninterface UseLiveStreamingArgs {\n  onLiveStreamingStarted?(ev: DailyEventObject<'live-streaming-started'>): void;\n  onLiveStreamingStopped?(ev: DailyEventObject<'live-streaming-stopped'>): void;\n  onLiveStreamingUpdated?(ev: DailyEventObject<'live-streaming-updated'>): void;\n  onLiveStreamingError?(ev: DailyEventObject<'live-streaming-error'>): void;\n  onLiveStreamingWarning?(ev: DailyEventObjectLiveStreamingWarning): void;\n}\n\n/**\n * This hook allows to setup [live streaming events](https://docs.daily.co/reference/daily-js/events/live-streaming-events),\n * as well as starting, stopping and updating live streams.\n *\n * Returns the current live streaming state, incl. the current layout and potential errorMsg.\n */\nexport const useLiveStreaming = ({\n  onLiveStreamingError,\n  onLiveStreamingStarted,\n  onLiveStreamingStopped,\n  onLiveStreamingUpdated,\n  onLiveStreamingWarning,\n}: UseLiveStreamingArgs = {}) => {\n  const daily = useDaily();\n  const state = useRecoilValue(liveStreamingState);\n\n  useDailyEvent(\n    'live-streaming-started',\n    useCallback(\n      (ev) => {\n        onLiveStreamingStarted?.(ev);\n      },\n      [onLiveStreamingStarted]\n    )\n  );\n  useDailyEvent(\n    'live-streaming-stopped',\n    useCallback(\n      (ev) => {\n        onLiveStreamingStopped?.(ev);\n      },\n      [onLiveStreamingStopped]\n    )\n  );\n  useDailyEvent(\n    'live-streaming-updated',\n    useCallback(\n      (ev) => {\n        onLiveStreamingUpdated?.(ev);\n      },\n      [onLiveStreamingUpdated]\n    )\n  );\n  useDailyEvent(\n    'live-streaming-error',\n    useCallback(\n      (ev) => {\n        onLiveStreamingError?.(ev);\n      },\n      [onLiveStreamingError]\n    )\n  );\n  useDailyEvent(\n    'nonfatal-error',\n    useCallback(\n      (ev) => {\n        if (ev.type !== 'live-streaming-warning') return;\n        onLiveStreamingWarning?.(ev as DailyEventObjectLiveStreamingWarning);\n      },\n      [onLiveStreamingWarning]\n    )\n  );\n\n  const startLiveStreaming = useCallback(\n    (...args: Parameters<DailyCall['startLiveStreaming']>) => {\n      if (!daily) return;\n      daily.startLiveStreaming(...args);\n    },\n    [daily]\n  );\n\n  const stopLiveStreaming = useCallback(\n    (...args: Parameters<DailyCall['stopLiveStreaming']>) => {\n      if (!daily) return;\n      daily.stopLiveStreaming(...args);\n    },\n    [daily]\n  );\n\n  const updateLiveStreaming = useCallback(\n    (...args: Parameters<DailyCall['updateLiveStreaming']>) => {\n      if (!daily) return;\n      daily.updateLiveStreaming(...args);\n    },\n    [daily]\n  );\n\n  const result = {\n    ...state,\n    startLiveStreaming,\n    stopLiveStreaming,\n    updateLiveStreaming,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import { useDebugValue } from 'react';\nimport { useRecoilValue } from 'recoil';\n\nimport { localIdState } from '../DailyParticipants';\nimport { useParticipant } from './useParticipant';\n\n/**\n * Returns the [participants() object](https://docs.daily.co/reference/daily-js/instance-methods/participants) for the local user.\n * @deprecated Use [useLocalSessionId](https://docs.daily.co/reference/daily-react/use-local-session-id) instead.\n */\nexport const useLocalParticipant = (): ReturnType<typeof useParticipant> => {\n  const localId = useRecoilValue(localIdState);\n  const localParticipant = useParticipant(localId);\n  useDebugValue(localParticipant);\n  return localParticipant;\n};\n","import { DailyEventObjectNonFatalError } from '@daily-co/daily-js';\nimport { useCallback, useDebugValue } from 'react';\nimport { useRecoilValue } from 'recoil';\n\nimport { meetingSessionDataState } from '../DailyMeeting';\nimport { Reconstruct } from '../types/Reconstruct';\nimport { useDailyEvent } from './useDailyEvent';\n\ntype DailyEventObjectMeetingSessionDataError = Reconstruct<\n  DailyEventObjectNonFatalError,\n  'type',\n  'meeting-session-data-error'\n>;\n\ninterface Props {\n  onError?(ev: DailyEventObjectMeetingSessionDataError): void;\n}\n\n/**\n * Returns a meeting's current session data and topology.\n */\nexport const useMeetingSessionState = <T = any>({ onError }: Props = {}) => {\n  const meetingSessionState = useRecoilValue(meetingSessionDataState);\n\n  useDailyEvent(\n    'nonfatal-error',\n    useCallback(\n      (ev) => {\n        if (ev.type !== 'meeting-session-data-error') return;\n        onError?.(ev as DailyEventObjectMeetingSessionDataError);\n      },\n      [onError]\n    )\n  );\n\n  const result = {\n    data: meetingSessionState?.data as T,\n    topology: meetingSessionState?.topology,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import { DailyEventObject } from '@daily-co/daily-js';\nimport { useCallback, useDebugValue } from 'react';\nimport { useRecoilValue } from 'recoil';\n\nimport {\n  networkQualityState,\n  networkThresholdState,\n  topologyState,\n} from '../DailyNetwork';\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\n\ninterface UseNetworkArgs {\n  onNetworkConnection?(ev: DailyEventObject<'network-connection'>): void;\n  onNetworkQualityChange?(ev: DailyEventObject<'network-quality-change'>): void;\n}\n\n/**\n * Returns current information about network quality and topology.\n * Allows to setup event listeners for daily's [network events](https://docs.daily.co/reference/daily-js/events/network-events).\n */\nexport const useNetwork = ({\n  onNetworkConnection,\n  onNetworkQualityChange,\n}: UseNetworkArgs = {}) => {\n  const daily = useDaily();\n\n  const topology = useRecoilValue(topologyState);\n  const quality = useRecoilValue(networkQualityState);\n  const threshold = useRecoilValue(networkThresholdState);\n\n  useDailyEvent(\n    'network-connection',\n    useCallback(\n      (ev) => {\n        onNetworkConnection?.(ev);\n      },\n      [onNetworkConnection]\n    )\n  );\n  useDailyEvent(\n    'network-quality-change',\n    useCallback(\n      (ev) => {\n        onNetworkQualityChange?.(ev);\n      },\n      [onNetworkQualityChange]\n    )\n  );\n\n  const getStats = useCallback(async () => {\n    const newStats = await daily?.getNetworkStats();\n    return newStats?.stats;\n  }, [daily]);\n\n  const result = {\n    getStats,\n    quality,\n    threshold,\n    topology,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import { useDebugValue } from 'react';\n\nimport { useLocalSessionId } from './useLocalSessionId';\nimport { useParticipantProperty } from './useParticipantProperty';\n\n/**\n * Returns parsed permissions for a given participant.\n * In case no `sessionId` is passed, the hook returns permissions for the local participant.\n * @param sessionId The participant's session_id (optional)\n */\nexport const usePermissions = (sessionId?: string) => {\n  const localSessionId = useLocalSessionId();\n  const permissions = useParticipantProperty(\n    sessionId ?? localSessionId,\n    'permissions'\n  );\n\n  const canSendAudio =\n    typeof permissions?.canSend === 'boolean'\n      ? permissions?.canSend\n      : Boolean(permissions?.canSend?.has('audio'));\n  const canSendVideo =\n    typeof permissions?.canSend === 'boolean'\n      ? permissions?.canSend\n      : Boolean(permissions?.canSend?.has('video'));\n  const canSendCustomAudio =\n    typeof permissions?.canSend === 'boolean'\n      ? permissions?.canSend\n      : Boolean(permissions?.canSend?.has('customAudio'));\n  const canSendCustomVideo =\n    typeof permissions?.canSend === 'boolean'\n      ? permissions?.canSend\n      : Boolean(permissions?.canSend?.has('customVideo'));\n  const canSendScreenAudio =\n    typeof permissions?.canSend === 'boolean'\n      ? permissions?.canSend\n      : Boolean(permissions?.canSend?.has('screenAudio'));\n  const canSendScreenVideo =\n    typeof permissions?.canSend === 'boolean'\n      ? permissions?.canSend\n      : Boolean(permissions?.canSend?.has('screenVideo'));\n  const canAdminParticipants =\n    typeof permissions?.canAdmin === 'boolean'\n      ? permissions?.canAdmin\n      : Boolean(permissions?.canAdmin?.has('participants'));\n  const canAdminStreaming =\n    typeof permissions?.canAdmin === 'boolean'\n      ? permissions?.canAdmin\n      : Boolean(permissions?.canAdmin?.has('streaming'));\n  const canAdminTranscription =\n    typeof permissions?.canAdmin === 'boolean'\n      ? permissions?.canAdmin\n      : Boolean(permissions?.canAdmin?.has('transcription'));\n\n  const result = {\n    canAdminParticipants,\n    canAdminStreaming,\n    canAdminTranscription,\n    canSendAudio,\n    canSendCustomAudio,\n    canSendCustomVideo,\n    canSendScreenAudio,\n    canSendScreenVideo,\n    canSendVideo,\n    hasPresence: permissions?.hasPresence,\n    permissions,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import { DailyCall, DailyEventObject } from '@daily-co/daily-js';\nimport { useCallback, useDebugValue } from 'react';\nimport { useRecoilValue } from 'recoil';\n\nimport { recordingState } from '../DailyRecordings';\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\n\ninterface UseRecordingArgs {\n  onRecordingData?(ev: DailyEventObject<'recording-data'>): void;\n  onRecordingError?(ev: DailyEventObject<'recording-error'>): void;\n  onRecordingStarted?(ev: DailyEventObject<'recording-started'>): void;\n  onRecordingStopped?(ev: DailyEventObject<'recording-stopped'>): void;\n}\n\nexport const useRecording = ({\n  onRecordingData,\n  onRecordingError,\n  onRecordingStarted,\n  onRecordingStopped,\n}: UseRecordingArgs = {}) => {\n  const daily = useDaily();\n  const state = useRecoilValue(recordingState);\n\n  useDailyEvent(\n    'recording-started',\n    useCallback(\n      (ev) => {\n        onRecordingStarted?.(ev);\n      },\n      [onRecordingStarted]\n    )\n  );\n  useDailyEvent(\n    'recording-stopped',\n    useCallback(\n      (ev) => {\n        onRecordingStopped?.(ev);\n      },\n      [onRecordingStopped]\n    )\n  );\n  useDailyEvent(\n    'recording-error',\n    useCallback(\n      (ev) => {\n        onRecordingError?.(ev);\n      },\n      [onRecordingError]\n    )\n  );\n  useDailyEvent(\n    'recording-data',\n    useCallback(\n      (ev) => {\n        onRecordingData?.(ev);\n      },\n      [onRecordingData]\n    )\n  );\n\n  /**\n   * Starts the recording with the given optional options.\n   */\n  const startRecording = useCallback(\n    (...args: Parameters<DailyCall['startRecording']>) => {\n      if (!daily) return;\n      daily.startRecording(...args);\n    },\n    [daily]\n  );\n\n  /**\n   * Stops a recording.\n   */\n  const stopRecording = useCallback(\n    (...args: Parameters<DailyCall['stopRecording']>) => {\n      if (!daily) return;\n      daily.stopRecording(...args);\n    },\n    [daily]\n  );\n\n  /**\n   * Updates a running recording's layout configuration.\n   */\n  const updateRecording = useCallback(\n    (...args: Parameters<DailyCall['updateRecording']>) => {\n      if (!daily) return;\n      daily.updateRecording(...args);\n    },\n    [daily]\n  );\n\n  const result = {\n    ...state,\n    startRecording,\n    stopRecording,\n    updateRecording,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import { useDebugValue, useEffect, useState } from 'react';\nimport { useRecoilValue } from 'recoil';\n\nimport { localJoinDateState } from '../DailyParticipants';\nimport { useRoom } from './useRoom';\n\ninterface Countdown {\n  hours: number;\n  minutes: number;\n  seconds: number;\n}\n\ninterface Props {\n  onCountdown?(countdown: Countdown): void;\n}\n\nexport const useRoomExp = ({ onCountdown }: Props = {}) => {\n  const localJoinDate = useRecoilValue(localJoinDateState);\n  const room = useRoom();\n\n  const [ejectDate, setEjectDate] = useState<Date | null>(null);\n\n  useEffect(() => {\n    const ejectAfterElapsed =\n      room?.tokenConfig?.eject_after_elapsed ??\n      room?.config?.eject_after_elapsed ??\n      0;\n    const expUTCTimeStamp = room?.tokenConfig?.exp ?? room?.config?.exp ?? 0;\n    const ejectAtExp =\n      room?.tokenConfig?.eject_at_token_exp ??\n      room?.config?.eject_at_room_exp ??\n      false;\n\n    let newEjectDate: Date = new Date(0);\n\n    if (ejectAfterElapsed && localJoinDate) {\n      newEjectDate = new Date(\n        localJoinDate.getTime() + 1000 * ejectAfterElapsed\n      );\n    }\n\n    if (ejectAtExp && expUTCTimeStamp) {\n      const expDate = new Date(expUTCTimeStamp * 1000);\n      if (\n        !newEjectDate.getTime() ||\n        (newEjectDate.getTime() > 0 && expDate < newEjectDate)\n      )\n        newEjectDate = expDate;\n    }\n\n    if (newEjectDate.getTime() === 0) return;\n\n    setEjectDate((oldEjectDate) =>\n      oldEjectDate?.getTime() !== newEjectDate.getTime()\n        ? newEjectDate\n        : oldEjectDate\n    );\n  }, [\n    localJoinDate,\n    room?.config?.eject_after_elapsed,\n    room?.config?.eject_at_room_exp,\n    room?.config?.exp,\n    room?.tokenConfig?.eject_after_elapsed,\n    room?.tokenConfig?.eject_at_token_exp,\n    room?.tokenConfig?.exp,\n  ]);\n\n  useEffect(() => {\n    if (!ejectDate || ejectDate.getTime() === 0) return;\n\n    const interval = setInterval(() => {\n      const eject = (ejectDate?.getTime() ?? 0) / 1000;\n      const now = Date.now() / 1000;\n      const diff = eject - now;\n      if (diff < 0) return;\n      const hours = Math.max(0, Math.floor(diff / 3600));\n      const minutes = Math.max(0, Math.floor((diff % 3600) / 60));\n      const seconds = Math.max(0, Math.floor(diff % 60));\n      onCountdown?.({\n        hours,\n        minutes,\n        seconds,\n      });\n    }, 1000);\n    return () => {\n      clearInterval(interval);\n    };\n  }, [ejectDate, onCountdown]);\n\n  const result = {\n    ejectDate,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import { MediaTrackState, useMediaTrack } from './useMediaTrack';\n\n/**\n * Returns a participant's screenAudio track and state.\n * @param participantId The participant's session_id.\n */\nexport const useScreenAudioTrack = (participantId: string): MediaTrackState =>\n  useMediaTrack(participantId, 'screenAudio');\n","import { MediaTrackState, useMediaTrack } from './useMediaTrack';\n\n/**\n * Returns a participant's screenVideo track and state.\n * @param participantId The participant's session_id.\n */\nexport const useScreenVideoTrack = (participantId: string): MediaTrackState =>\n  useMediaTrack(participantId, 'screenVideo');\n","import {\n  DailyCall,\n  DailyEventObject,\n  DailyEventObjectAppMessage,\n} from '@daily-co/daily-js';\nimport { useCallback, useDebugValue } from 'react';\nimport { useRecoilValue } from 'recoil';\n\nimport { Transcription, transcriptionState } from '../DailyTranscriptions';\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\n\ninterface UseTranscriptionArgs {\n  onTranscriptionStarted?(ev: DailyEventObject<'transcription-started'>): void;\n  onTranscriptionStopped?(ev: DailyEventObject<'transcription-stopped'>): void;\n  onTranscriptionError?(ev: DailyEventObject<'transcription-error'>): void;\n  onTranscriptionAppData?(ev: DailyEventObjectAppMessage<Transcription>): void;\n}\n\nexport const useTranscription = ({\n  onTranscriptionAppData,\n  onTranscriptionError,\n  onTranscriptionStarted,\n  onTranscriptionStopped,\n}: UseTranscriptionArgs = {}) => {\n  const daily = useDaily();\n\n  const state = useRecoilValue(transcriptionState);\n\n  useDailyEvent(\n    'transcription-started',\n    useCallback(\n      (ev) => {\n        onTranscriptionStarted?.(ev);\n      },\n      [onTranscriptionStarted]\n    )\n  );\n  useDailyEvent(\n    'transcription-stopped',\n    useCallback(\n      (ev) => {\n        onTranscriptionStopped?.(ev);\n      },\n      [onTranscriptionStopped]\n    )\n  );\n  useDailyEvent(\n    'transcription-error',\n    useCallback(\n      (ev) => {\n        onTranscriptionError?.(ev);\n      },\n      [onTranscriptionError]\n    )\n  );\n  useDailyEvent(\n    'app-message',\n    useCallback(\n      (ev: DailyEventObjectAppMessage<Transcription>) => {\n        if (ev?.fromId === 'transcription' && ev?.data?.is_final) {\n          onTranscriptionAppData?.(ev);\n        }\n      },\n      [onTranscriptionAppData]\n    )\n  );\n\n  /**\n   * Starts the transcription with the given optional options.\n   */\n  const startTranscription = useCallback(\n    (...args: Parameters<DailyCall['startTranscription']>) => {\n      if (!daily) return;\n      daily.startTranscription(...args);\n    },\n    [daily]\n  );\n\n  /**\n   * Stops a transcription.\n   */\n  const stopTranscription = useCallback(\n    (...args: Parameters<DailyCall['stopTranscription']>) => {\n      if (!daily) return;\n      daily.stopTranscription(...args);\n    },\n    [daily]\n  );\n\n  const result = {\n    ...state,\n    startTranscription,\n    stopTranscription,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import { MediaTrackState, useMediaTrack } from './useMediaTrack';\n\n/**\n * Returns a participant's video track and state.\n * @param participantId The participant's session_id.\n */\nexport const useVideoTrack = (participantId: string): MediaTrackState =>\n  useMediaTrack(participantId, 'video');\n","import { DailyEventObject } from '@daily-co/daily-js';\nimport { useCallback, useDebugValue } from 'react';\nimport { useRecoilValue } from 'recoil';\n\nimport { allWaitingParticipantsSelector } from '../DailyParticipants';\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\n\ninterface UseWaitingParticipantsArgs {\n  onWaitingParticipantAdded?(\n    ev: DailyEventObject<'waiting-participant-added'>\n  ): void;\n  onWaitingParticipantUpdated?(\n    ev: DailyEventObject<'waiting-participant-updated'>\n  ): void;\n  onWaitingParticipantRemoved?(\n    ev: DailyEventObject<'waiting-participant-removed'>\n  ): void;\n}\n\n/**\n * Hook to access and manage waiting participants.\n */\nexport const useWaitingParticipants = ({\n  onWaitingParticipantAdded,\n  onWaitingParticipantRemoved,\n  onWaitingParticipantUpdated,\n}: UseWaitingParticipantsArgs = {}) => {\n  const daily = useDaily();\n\n  const waitingParticipants = useRecoilValue(allWaitingParticipantsSelector);\n\n  useDailyEvent(\n    'waiting-participant-added',\n    useCallback(\n      (ev) => {\n        onWaitingParticipantAdded?.(ev);\n      },\n      [onWaitingParticipantAdded]\n    )\n  );\n  useDailyEvent(\n    'waiting-participant-removed',\n    useCallback(\n      (ev) => {\n        onWaitingParticipantRemoved?.(ev);\n      },\n      [onWaitingParticipantRemoved]\n    )\n  );\n  useDailyEvent(\n    'waiting-participant-updated',\n    useCallback(\n      (ev) => {\n        onWaitingParticipantUpdated?.(ev);\n      },\n      [onWaitingParticipantUpdated]\n    )\n  );\n\n  const updateWaitingParticipantAccess = useCallback(\n    (id: '*' | string, grantRequestedAccess: boolean) => {\n      if (id === '*') {\n        daily?.updateWaitingParticipants({\n          '*': {\n            grantRequestedAccess,\n          },\n        });\n        return;\n      }\n      daily?.updateWaitingParticipant(id, {\n        grantRequestedAccess,\n      });\n    },\n    [daily]\n  );\n\n  const grantAccess = useCallback(\n    (id: '*' | string) => {\n      updateWaitingParticipantAccess(id, true);\n    },\n    [updateWaitingParticipantAccess]\n  );\n\n  const denyAccess = useCallback(\n    (id: '*' | string) => {\n      updateWaitingParticipantAccess(id, false);\n    },\n    [updateWaitingParticipantAccess]\n  );\n\n  const result = {\n    waitingParticipants,\n    grantAccess,\n    denyAccess,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n"],"names":["DailyContext","createContext","useDaily","daily","useContext","useDebugValue","DailyEventContext","on","off","uniqueCounter","getUnique","useDailyEvent","ev","callback","useState","isBlocked","setIsBlocked","reassignCount","useRef","eventId","useMemo","useEffect","current","console","error","timeout","setTimeout","clearTimeout","event","participantPropertyPathsState","atomFamily","key","RECOIL_PREFIX","participantPropertyState","dangerouslyAllowMutability","participantPropertiesState","selectorFamily","get","id","properties","map","path","property","useParticipantProperty","participantId","propertyPaths","useRecoilValue","Array","isArray","reduce","o","i","useThrottledDailyEvent","throttleTimeout","r","e","throttledEvents","useCallback","length","emitEvents","throttle","trailing","addEvent","push","forEach","customDeepEqual","a","b","MediaStream","active","getTracks","every","track","idx","MediaStreamTrack","kind","readyState","Date","getTime","RegExp","source","flags","Set","size","values","has","Map","entries","value","keysA","Object","keys","keysB","equalSelector","options","prior","inner","selector","latest","equals","equalSelectorFamily","priorValues","param","set","getParticipantPaths","p","getPaths","currentPath","paths","prototype","hasOwnProperty","call","newPath","resolveParticipantPaths","participant","String","split","filter","resolvePath","activeIdState","atom","localIdState","localJoinDateState","participantIdsState","participantState","waitingParticipantsState","waitingParticipantState","awaitingAccess","level","name","allWaitingParticipantsSelector","DailyParticipants","children","initialized","setInitialized","initParticipants","useRecoilCallback","transact_UNSTABLE","participants","local","session_id","participantsArray","ids","interval","setInterval","clearInterval","handleInitEvent","evts","reset","action","activeSpeaker","peerId","prev","last_active","prevIds","includes","prevId","oldPaths","wps","wp","React","useLocalSessionId","localId","noopFilter","useActiveSpeakerId","ignoreLocal","localSessionId","recentActiveId","isIgnoredLocalId","isFilteredOut","activeId","setActiveId","isTrackOff","trackState","participantIdsFilteredAndSortedState","sort","screenVideoState","idA","idB","aSort","bSort","undefined","useParticipantIds","onActiveSpeakerChange","onParticipantJoined","onParticipantLeft","onParticipantUpdated","preFilteredSortedIds","getCustomFilteredIds","snapshot","getLoadable","contents","Boolean","customIds","setCustomIds","maybeUpdateCustomIds","newIds","result","screenSharesState","screenAudio","screenVideo","screenId","useScreenShare","onError","onLocalScreenShareStarted","onLocalScreenShareStopped","startScreenShare","args","stopScreenShare","type","screens","isSharingScreen","some","s","useMediaTrack","isOff","state","persistentTrack","subscribed","useMergedRef","refs","element","ref","DailyAudioTrack","memo","forwardRef","onPlayFailed","sessionId","props","audioEl","audio","audioRef","subscribedState","audioTag","handleCanPlay","play","target","message","handlePlay","playTimeout","addEventListener","srcObject","removeEventListener","autoPlay","playsInline","displayName","DailyAudio","autoSubscribeActiveSpeaker","maxSpeakers","playLocalScreenAudio","fill","speakers","setSpeakers","activeSpeakerId","containerRef","useImperativeHandle","getActiveSpeakerAudio","_containerRef$current2","querySelector","getAllAudio","from","_containerRef$current4","querySelectorAll","getAudioBySessionId","_containerRef$current6","getRmpAudio","_containerRef$current8","getScreenAudio","_containerRef$current10","getRmpAudioBySessionId","_containerRef$current12","getScreenAudioBySessionId","_containerRef$current14","assignSpeaker","subscribedParticipants","tracks","isSubscribed","isDestroyed","subscribeToTracksAutomatically","updateParticipant","setSubscribedTracks","prevSpeakers","freeSlotCheck","findIndex","mutedIdx","speakerObjects","lastActiveA","lastActiveB","replaceIdx","indexOf","_speakerObjects$","removeSpeaker","newSpeakers","rmpAudioIds","_p$tracks","rmpAudio","screen","DailyVideo","automirror","fit","mirror","onResize","playableStyle","style","isLocal","isScreen","isLocalCam","videoEl","videoRef","videoState","videoTrack","isPlayable","isMirrored","videoTrackSettings","getSettings","facingMode","video","playVideo","promise","then","controls","warn","paused","handleEnterPIP","transform","handleLeavePIP","handleVisibilityChange","document","visibilityState","load","frame","handleResize","cancelAnimationFrame","requestAnimationFrame","hidden","videoWidth","videoHeight","aspectRatio","height","width","muted","objectFit","DailyDevicesContext","refreshDevices","Promise","resolve","generalCameraState","generalMicrophoneState","cameraDevicesState","microphoneDevicesState","speakerDevicesState","lastCameraErrorState","DailyDevices","navigator","_navigator","mediaDevices","_navigator$mediaDevic","getUserMedia","_navigator2","_navigator2$mediaDevi","enumerateDevices","devices","cams","d","deviceId","mics","getInputDevices","camera","mic","speaker","mapDevice","device","prevDevices","selected","find","_prevDevices$find","sortDeviceByLabel","label","prevCams","prevMics","updateDeviceStates","currentCamState","getPromise","currentMicState","camPermissionState","micPermissionState","permissions","query","awaitingCamAccess","initialCamOff","_tracks$video$off","byUser","awaitingMicAccess","initialMicOff","_tracks$audio$off","_tracks$audio","blocked","_tracks$audio$blocked","byDeviceInUse","m","_tracks$audio2","_tracks$audio2$blocke","byDeviceMissing","byPermissions","_tracks$video","_tracks$video$blocked","_tracks$video2","_tracks$video2$blocke","_ev$error","_ev$error2","missingMedia","_ev$error3","_ev$error4","blockedMedia","_ev$error5","reason","Provider","liveStreamingState","errorMsg","isLiveStreaming","layout","DailyLiveStreaming","prevState","meetingStateState","meetingErrorState","nonFatalErrorState","meetingSessionDataState","data","topology","DailyMeeting","updateMeetingState","meetingState","initMeetingSessionState","meetingSessionState","topologyState","networkQualityState","networkThresholdState","DailyNetwork","initTopology","getNetworkTopology","prevQuality","quality","prevThreshold","threshold","recordingState","isLocalParticipantRecorded","isRecording","DailyRecordings","setState","useSetRecoilState","recordingParticipantIds","hasRecordingParticipants","isLocalParticipantRecording","preset","recordingId","recordingStartedDate","startedBy","useMeetingState","roomState","DailyRoom","updateRoom","room","transcriptionState","isTranscribing","model","language","transcriptions","DailyTranscriptions","transcriptionStartDate","updatedBy","fromId","_ev$data","is_final","defaultOptions","defaultShouldCreateInstance","defaultProps","shouldCreateInstance","useCallInstance","parentEl","callInstance","setCallInstance","lastUsedOptions","handleDestroyedInstance","co","Daily","getCallInstance","once","destroyCallInstance","createFrame","createCallObject","destroy","useCallObject","useParticipant","filteredEvts","inlineAudioWorklet","encodeURIComponent","CPULoadState","useDailyError","meetingError","nonFatalError","inputSettingsState","participantCountsState","present","participantReceiveSettingsState","useRoom","sendSettingsState","recoilRootProps","eventsMap","handleEvent","_eventsMap$current","_eventsMap$current$ev2","cb","initEventHandlers","externalCallObject","callObject","memoizedOptions","internalCallObject","_eventsMap$current$ev3","RecoilRoot","activeParticipant","_daily$participants","onAppMessage","sendAppMessage","to","handleAppMessage","mediaTrack","onVolumeChange","audioCtx","AudioCtx","AudioContext","window","webkitAudioContext","audioContext","node","gainNode","mediaStreamSource","createMediaStreamSource","AudioWorkletNode","createGain","audioWorklet","addModule","port","onmessage","volume","gain","connect","destination","startProcessing","disconnect","onCPULoadChange","cpu","updateCPULoadState","deepEqual","mounted","getCpuLoadStats","stats","cpuLoadState","cpuLoadStateReason","camState","micState","camDevices","micDevices","speakerDevices","cameraError","setCamera","setInputDevicesAsync","audioDeviceId","videoDeviceId","setMicrophone","setSpeaker","setOutputDeviceAsync","outputDeviceId","errorStates","cameras","currentCam","cam","currentMic","currentSpeaker","hasCamError","hasMicError","microphones","onInputSettingsUpdated","inputSettings","updateInputSettingsState","getInputSettings","updateInputSettings","onLiveStreamingError","onLiveStreamingStarted","onLiveStreamingStopped","onLiveStreamingUpdated","onLiveStreamingWarning","startLiveStreaming","stopLiveStreaming","updateLiveStreaming","localParticipant","onNetworkConnection","onNetworkQualityChange","getStats","newStats","getNetworkStats","onParticipantCountsUpdated","participantCounts","updateCounts","counts","canSendAudio","canSend","_permissions$canSend","canSendVideo","_permissions$canSend2","canSendCustomAudio","_permissions$canSend3","canSendCustomVideo","_permissions$canSend4","canSendScreenAudio","_permissions$canSend5","canSendScreenVideo","_permissions$canSend6","canAdminParticipants","canAdmin","_permissions$canAdmin","canAdminStreaming","_permissions$canAdmin2","canAdminTranscription","_permissions$canAdmin3","hasPresence","onReceiveSettingsUpdated","baseSettings","receiveSettings","updateReceiveSettingsState","settings","getReceiveSettings","updateReceiveSettings","onRecordingData","onRecordingError","onRecordingStarted","onRecordingStopped","startRecording","stopRecording","updateRecording","onCountdown","localJoinDate","ejectDate","setEjectDate","ejectAfterElapsed","tokenConfig","_room$tokenConfig","eject_after_elapsed","config","_room$config","expUTCTimeStamp","_room$tokenConfig2","exp","_room$config2","ejectAtExp","_room$tokenConfig3","eject_at_token_exp","_room$config3","eject_at_room_exp","newEjectDate","expDate","oldEjectDate","_room$config4","_room$config5","_room$config6","_room$tokenConfig4","_room$tokenConfig5","_room$tokenConfig6","diff","now","hours","Math","max","floor","minutes","seconds","onSendSettingsUpdated","sendSettings","storeSendSettings","getSendSettings","updateSendSettings","newSendSettings","onTranscriptionAppData","onTranscriptionError","onTranscriptionStarted","onTranscriptionStopped","startTranscription","stopTranscription","onWaitingParticipantAdded","onWaitingParticipantRemoved","onWaitingParticipantUpdated","waitingParticipants","updateWaitingParticipantAccess","grantRequestedAccess","updateWaitingParticipant","updateWaitingParticipants","grantAccess","denyAccess"],"mappings":"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"}